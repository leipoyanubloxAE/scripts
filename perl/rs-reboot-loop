#!/usr/bin/perl
#
# Script: rs-reboot-loop
#
# This script will login to the specified router the specified number of times.
#  Each time it will wait for SolOS to be up and running.  At that point it
# will execute the specified command (if one is specified), record the result
# and then reboot the router.
# 
#
# The framework of the script was autogenerated by version 2153 of
# /usr/local/devtools/bin/super-script.
#
#############################################################################


use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;
use Pod::Usage;

use constant BOLD    => "\e[1m";
use constant NORMAL  => "\e[0m";

my $BOLD   = BOLD;
my $NORMAL = NORMAL;
my $BOLDr  = "[31m[1m";  # Red
my $BOLDg  = "[32m[1m";  # Green

# Main hash - all the argument values will be in here after parsing
my %args = (
            router => undef,
            num_reboots => '-1',
            cmd => '',
            debug => undef,
            gen_completion => undef,
            help => undef,
            interactive => undef,
            quiet => undef,
            short_help => undef,
            tiny_help => undef,
            verbose => undef,
);

# Arrays to hold the parsed and unparsed args
my @remainingArgs;
my @allArgs;
my @parsedArgs;
my %parsedArgs;

ParseArgs();

##--User Code Start--##

use Expect;
use Term::ReadKey;

# Don't modify anything outside of the User Code Start/End markers or
# it will be lost if the script's configuration is changed

# Call main - the start of the script
Main();

##############################################################################
## Main - Starting point for the script
##
##############################################################################
sub Main {

  my $exp;
  
  while ($args{num_reboots} != 0) {
    ConnectToRouter(\$exp);
    if (WaitForStartComplete($exp)) {
      sleep(30);
      print "rebooting\n";
      RunCommandAndReboot($exp);
      $exp->close();
      $args{num_reboots}--;
    }
    else {
      $exp->close();
    }
  }

}


##############################################################################
## RunCommandAndReboot - 
##
## Send the specified command.  Wait a bit and then issue a reboot 
##
##############################################################################
sub RunCommandAndReboot {
  my ($exp) = @_;

  $exp->clear_accum();
  my @cmds = split(/;/, $args{cmd});

  foreach my $cmd (@cmds) {
    print "Sending command: $cmd\n";
    $exp->send("$cmd\r");
    my $match = $exp->expect(20, "# ");
    print $exp->before() . "\n";
  }

  $exp->send("reboot\r");
  $exp->expect(10, "]# ");
  sleep(20);

} # RunCommandAndReboot #


##############################################################################
## WaitForStartComplete - This will return when SolOS is up and running 
##
##############################################################################
sub WaitForStartComplete {
  my ($exp) = @_;
  while (1) {
    
    $exp->send("cli\r");
    my $match = $exp->expect(10, 
                             ['-re', 'Copyright'], 
                             ['-re', 'in progress']);
    
    if (!$match) {
      print "Return 0\n";
      return 0;
    }
    if ($match == 1) {
      # CLI is running - exit and return
      $exp->clear_accum();
      $exp->send("exit\r");
      $exp->expect(2, "]# ");
      $exp->clear_accum();
      return 1;
    }
    
    sleep(2);
    $exp->clear_accum();
  }

  return 1;

} # WaitForStartComplete #



##############################################################################
## ConnectToRouter - This will log into the router 
##
##############################################################################
sub ConnectToRouter {
  my ($expPtr) = @_;

  ReadMode 0;
  print "Trying to connect to $args{router}...";
  while(1) {
    $$expPtr = new Expect();
    $$expPtr->raw_pty(1);
    $$expPtr->log_stdout(1);
    $$expPtr->spawn("ssh", "root\@$args{router}");
  
    my $match = $$expPtr->expect(5, 
                                 ['-re', 'Password: '], 
                                 ['-re', '\]# ']);

    if ($match) {
      if ($match == 2) {
        last;
      }
      elsif ($match == 1) {
        $$expPtr->send("solace1");
      }
    }
    print ".";
    sleep(1);
  }

  $$expPtr->clear_accum();
  
  print "\n";

} # ConnectToRouter #



##--User Code End--##



##############################################################################
## ParseArgs - Will do all the argument parsing
##
##############################################################################
sub ParseArgs {
  
  # Options Parsing
  @allArgs = @ARGV;

  my %defaultArgs = %args;
  %args = ();

  # Converts position arguments to names
  my @posToName = (
              'router',
  );

  # Converts position arguments to names
  my @posToType = (
              'string',
  );

  # All required arguments
  my %requiredArgs = (
                       'router' => 1,
  );

  # All enum arguments
  my %enumArgs = (
  );

  # Cross ref of perl version of args to command line version
  my %perlToCmdArg = (
                       'router' => 'router',
                       'num_reboots' => 'num-reboots',
                       'cmd' => 'cmd',
                       'debug' => 'debug',
                       'gen_completion' => 'gen-completion',
                       'help' => 'help',
                       'interactive' => 'interactive',
                       'quiet' => 'quiet',
                       'short_help' => 'short-help',
                       'tiny_help' => 'tiny-help',
                       'verbose' => 'verbose',
  );

  my $result = GetOptions (
                           'num-reboots=o' => \$args{num_reboots},
                           'cmd=s' => \$args{cmd},
                           'debug' => \$args{debug},
                           'gen-completion' => \$args{gen_completion},
                           'help' => \$args{help},
                           'interactive' => \$args{interactive},
                           'quiet' => \$args{quiet},
                           'short-help' => \$args{short_help},
                           'tiny-help' => \$args{tiny_help},
                           'verbose' => \$args{verbose},
  );

  if (!$result) { exit(1); }


  # Positional argument processing

  my $posIdx = 0;
  while (@ARGV) {
    if ($posIdx >= 1) {
      last;
    }
  
    $args{$posToName[$posIdx]} = shift @ARGV;
    if ($posToType[$posIdx] eq 'integer') {
      $args{$posToName[$posIdx]} = 
         StrToNum($args{$posToName[$posIdx]}, "Failed to convert $args{$posToName[$posIdx]} to number");
    }
    delete $requiredArgs{$posToName[$posIdx]};
    $posIdx++;
  }
  @remainingArgs = @ARGV;
  @parsedArgs = @allArgs[0..(scalar(@allArgs)-scalar(@remainingArgs)-1)];

  if($#ARGV > -1) { 
    print "${BOLDr}Unrecognized argument(s):$NORMAL ";
    foreach (@ARGV) { print "$_ "; } print "\n";
    exit 1;
  }

  # Copy over all the arguments that were parsed
  foreach my $arg (keys(%args)) {
    if (defined $args{$arg}) {
      $parsedArgs{$arg} = 1;
    }
  }

  # Put back the default arguments
  foreach my $arg (keys(%defaultArgs)) {
    if (!defined($args{$arg})) {
      $args{$arg} = $defaultArgs{$arg};
    }
  }


  # Standard option processing

  if ($args{gen_completion}) {
    print "--num-reboots --cmd --debug --help --interactive --quiet --short-help --tiny-help --verbose ";
    exit;
  }

  if ($args{help}) {
    pod2usage(-verbose => 2);    
    exit;
  }
  if ($args{short_help}) {
    pod2usage(-verbose => 1);
    exit;
  }
  if ($args{tiny_help}) {
    my $info = GetArgInfo();
    print "$info->{Name} - $info->{ShortDescription}\n";
    exit;
  }
  my $showCmdLine = 0;
  if ($args{interactive}) {
    PromptForArgs(1, %args);
    $showCmdLine = 1;
  }
  
  # Check for missing required params
  foreach my $key (keys(%requiredArgs)) {
    if (defined $args{$key}) {
      delete $requiredArgs{$key};
    }
  }
  if (scalar(keys(%requiredArgs)) > 0) {
    print "\nMissing some required parameters\n";
    PromptForArgs(1, %requiredArgs);
    $showCmdLine = 1;
  }
  
  # Check that enums have valid values
  my $argInfo = GetArgInfo();
  foreach my $arg (keys(%enumArgs)) {
    if (defined $args{$arg}) {
      if (not defined $enumArgs{$arg}{$args{$arg}}) {
        print "\nInvalid value for argument $arg.  Valid values are:\n";
        foreach my $value (keys(%{$enumArgs{$arg}})) {
          print "  $value\n";
        }
        exit;
      }
    }
  }
  
  if ($showCmdLine) {
    # Output the command line for this
    DisplayCommandLine();
  }

} # ParseArgs


##############################################################################
## PromptForArgs - Will ask the user for values for various arguments
##
## skipAutoArgs: When true, it will not prompt for --interactive, --debug,
##               --quiet, --verbose or --help
##
##############################################################################
sub PromptForArgs {
  my ($skipAutoArgs, %argsForPrompting) = @_;
  my $argInfo = GetArgInfo();
  
  print "\nInteractive Input:\n\n";
  foreach my $arg (@{$argInfo->{Args}}) {
    my $name = $arg->{Name};
    my $perlName = $arg->{PerlName};
    if (not exists $argsForPrompting{$perlName}) {
      next;
    }
    if ($skipAutoArgs && 
        ($name =~ /^(debug)|(interactive)|(quiet)|(verbose)|(help)|(gen-completion)$/)) {
      next;
    }
    my $desc = $arg->{Description};
    my $space = " " x (length($name) + 3);
    $desc =~ s/(.{1,75 - length($name)})(?:\s|$|\n)/$1\n$space/g;
    my $prompt = "\n$BOLD$name$NORMAL - $arg->{Description}";
    my $default = '';
    my $defVal = '';
    if (defined $args{$perlName}) {
      $default = " [$args{$perlName}]";
      $defVal = $args{$perlName};
    }
    elsif ($arg->{Default}) {
      $default = " [$arg->{Default}]";
      $defVal = $arg->{Default};
    }
    while (1) {
      if ($arg->{ValType} eq 'boolean') {
        print $prompt . "\nEnter value for flag (undef, 0 or 1)$default: ";
      }
      elsif ($arg->{ValType} =~ /integer|float/) {
        print $prompt . "\nEnter numeric value$default: ";
      }
      elsif ($arg->{ValType} eq 'enum') {
        print $prompt . "\nSelect value: ";
      }
      else {
        print $prompt . "\nEnter value$default: ";
      }
      my $response;
      if ($arg->{ValType} eq 'enum') {
        print "\n";
        $default = '';
        my $num = 1;
        my $defaultNum;
        foreach my $val (@{$arg->{EnumList}}) {
          print "  $num: $val\n";
          if ($val eq $defVal) {
            $default = "[$num]";
            $defaultNum = $num;
          }
          $num++;
        }
        while (1) {
          print "Select number$default: "; 
          chomp($response = <STDIN>);
          if ($response eq '') {
            $response = defined $defaultNum ? $defaultNum : 0;
          }
          if ($response >= 1 &&
              $response <= scalar(@{$arg->{EnumList}})) {
            $response = $arg->{EnumList}[$response-1];
            last;
          }
          print "Invalid selection - try again\n";
        }
      }
      else {
        chomp($response = <STDIN>);
      }
      if ($arg->{Required} && 
          (not defined $args{$perlName}) &&
          $response eq '') {
        print "You must enter a value for this argument\n";
      }
      else {
        if ($response eq '' && 
            defined $args{$perlName}) {
          # Keep the same value
        }
        elsif ($response eq '' && 
               defined $arg->{Default}) {
          $args{$perlName} = $arg->{Default};
        }
        else {
          if ($arg->{ValType} eq 'integer') {
            $args{$perlName} =
              StrToNum($response, "Failed to convert $response to number");
          }
          else {
            $args{$perlName} = $response;
          }
        }
        if (($arg->{ValType} eq 'boolean') && 
            (($args{$perlName} eq 'undef') || ($args{$perlName}) eq ''))  {
          $args{$perlName} = undef;
        }
        last;
      }
    }
  }

}



##############################################################################
## GetArgInfo - This will return all the script information in perl
##              struct form.
##
##############################################################################
sub GetArgInfo {

  my $cfgInfo = {
             'SuperScriptRevision' => '2153',
             'ShortDescription' => 'Reboot the router and run a command, over and over',
             'ParsingType' => 'unordered',
             'Description' => 'This script will login to the specified router the specified number of times.  Each time it will wait for SolOS to be up and running.  At that point it will execute the specified command (if one is specified), record the result and then reboot the router.
',
             'Name' => 'rs-reboot-loop',
             'Args' => [
                         {
                           'Type' => 'positional',
                           'Required' => 1,
                           'ValType' => 'string',
                           'Description' => 'The router to run against',
                           'Name' => 'router',
                           'PerlName' => 'router'
                         },
                         {
                           'Type' => 'named',
                           'Default' => '-1',
                           'Required' => 0,
                           'ValType' => 'integer',
                           'Name' => 'num-reboots',
                           'Description' => 'How many times to reboot',
                           'PerlName' => 'num_reboots'
                         },
                         {
                           'Type' => 'named',
                           'Default' => '',
                           'Required' => 0,
                           'ValType' => 'string',
                           'Name' => 'cmd',
                           'Description' => 'Command to run before reboot',
                           'PerlName' => 'cmd'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Turn on all debug output.',
                           'Name' => 'debug',
                           'PerlName' => 'debug'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Prints out completion info for the parameters',
                           'Name' => 'gen-completion',
                           'PerlName' => 'gen_completion'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out usage info for this script',
                           'Name' => 'help',
                           'PerlName' => 'help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Query the user for values for each of the arguments, providing help for each.  This will print out the appropriate command line for future reference before executing the script.',
                           'Name' => 'interactive',
                           'PerlName' => 'interactive'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Reduce the amount of output to the bare minimum.',
                           'Name' => 'quiet',
                           'PerlName' => 'quiet'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out usage summary for this script',
                           'Name' => 'short-help',
                           'PerlName' => 'short_help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out one line description for this script',
                           'Name' => 'tiny-help',
                           'PerlName' => 'tiny_help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out more user-level output',
                           'Name' => 'verbose',
                           'PerlName' => 'verbose'
                         }
                       ],
             'PositionalListIdx' => undef
           };

  return $cfgInfo;

} # GetArgInfo


##############################################################################
## DisplayCommandLine - This will print out the command line for the
##                      current arguments
##
##############################################################################
sub DisplayCommandLine {

  my $argInfo = GetArgInfo();

  # my $output = "$argInfo->{Name} ";
  my $output = "$0 ";
  my $positional = '';

  foreach my $arg (@{$argInfo->{Args}}) {
    my $name = $arg->{Name};
    my $perlName = $arg->{PerlName};
    if (not defined $args{$perlName}) {
      next;
    }
    if (defined $arg->{Default} && 
        $args{$perlName} eq $arg->{Default}) {
      next;
    }
    if ($perlName eq 'interactive') {
      next;
    }

    my $value = $args{$perlName};
    if ($value =~ /\s/) {
      $value = "'$value'";
    }
    
    if ($arg->{Type} eq 'named') {
      if ($arg->{ValType} eq 'boolean') {
        if (defined $args{$perlName}) {
          if ($args{$perlName} == 0) {
            $output .= "--no-$name ";
          }
          else {
            $output .= "--$name ";
          }
        }
      }
      else {
        $output .= "--$name=$value ";
      }
    }
    else {
      if (ref $value eq 'ARRAY') {
        if (scalar(@{$value} > 1) || $value->[0] ne '') {
          $positional .= "@{$value} ";
        }
      }
      else {
        $positional .= "$value ";
      }
    }

  }
  
  print "Command line:\n";
  print "$output$positional\n\n";

} # DisplayCommandLine #


##############################################################################
## Log - This will output messages of various levels
##
##############################################################################
sub Log {
  my ($level, $message, $addCaller) = @_;

  my $outputMsg = 0;
  if (!$args{quiet}) {
    if ($level eq "DEBUG") {
      if ($args{debug}) {
        $outputMsg = 1;
      }
    }
    elsif ($level eq "INFO") {
      if ($args{debug} || $args{verbose}) {
        $outputMsg = 1;
      }
    }
    elsif ($level eq "WARN") {
        $outputMsg = 1;
    }
  }

  if (($level eq "ERROR") || ($level eq "FATAL") || ($level eq "MSG")) {
    $outputMsg = 1;
  }
  
  if ($outputMsg) {
    if (($level ne "MSG") || $addCaller) {
      print "$level: ";
    }
    if ($addCaller) {
      my @caller = caller(1);
      $caller[1] =~ s/^.*\///;
      print "$caller[1]:$caller[2]: ";
    }
    print "$message\n";
  }

  if ($level eq "FATAL") {
    exit(1);
  }

} # Log

sub Fatal { Log("FATAL", @_) };
sub Error { Log("ERROR", @_) };
sub Warn  { Log("WARN", @_) };
sub Info  { Log("INFO", @_) };
sub Debug { Log("DEBUG", @_) };
sub Msg   { Log("MSG", @_) };



##############################################################################
## StrToNum - This will convert all types of strings into numbers
##
##############################################################################
sub StrToNum {
  my ($string, $failMsg) = @_;

  if ($string !~ 
      /^([-+]?_*[1-9][0-9_]*  |
         0x_*[0-9a-f][0-9a-f_]* |
         0b_*[01][01_]*         |
         0[0-7_]*)$
      /xi) {
    Fatal($failMsg);
  }

  my $num = eval($string);
  
  if ($@) {
    Fatal($@);
  }

  return $num;

}
  



__END__

=head1 NAME

rs-reboot-loop

=head1 DESCRIPTION

This script will login to the specified router the specified number of times.  Each time it will wait for SolOS to be up and running.  At that point it will execute the specified command (if one is specified), record the result and then reboot the router.


=head1 OPTIONS

rs-reboot-loop [OPTIONS] <router> 

Where:

=over

=item router (string) B<*Required*>

The router to run against

=item --num-reboots=<integer>

How many times to reboot
[Default: -1]

=item --cmd=<string>

Command to run before reboot

=item --gen-completion

Prints out completion info for the parameters

=item --interactive

Query the user for values for each of the arguments, providing help for each.  This will print out the appropriate command line for future reference before executing the script.

=item --help, --short-help, --tiny-help

Display various levels of usage information

=item --quiet, --verbose, --debug

Control the amount of information printed during execution

=back

