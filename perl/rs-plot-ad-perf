#!/usr/bin/perl
#
# Script: prof-plot
#
# Plot the output from the AD Profiler Tool following execution of soldebug
# :conn 3 adDumpProcessHistory command
# 
#
# The framework of the script was autogenerated by version 5740 of
# /opt/soldev/devtools/bin/super-script.
#
#############################################################################


use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;
use Pod::Usage;

use constant BOLD    => "\e[1m";
use constant NORMAL  => "\e[0m";
my $BOLD   = BOLD;
my $NORMAL = NORMAL;
my $BOLDr  = "\e[31m\e[1m";  # Red
my $BOLDg  = "\e[32m\e[1m";  # Green


# Main hash - all the argument values will be in here after parsing
my %args = (
            router => 'router',
            file => 'undefined',
            port => '2222',
            queue => '0',
            process => '1',
            cfg_file => '~/.rs-perf-plot',
            stats => '0',
            rate => '0',
            column => '5',
            threshold => '1',
            debug => undef,
            gen_completion => undef,
            help => undef,
            interactive => undef,
            quiet => undef,
            short_help => undef,
            tiny_help => undef,
            verbose => undef,
);

# Arrays to hold the parsed and unparsed args
my @remainingArgs;
my @allArgs;
my @parsedArgs;
my %parsedArgs;

ParseArgs();

##--User Code Start--##

use FindBin;
use lib "$FindBin::Bin/../../../lib/perl";
use lib "$FindBin::Bin/../lib/perl";
use Solace::Expect;
use Time::HiRes qw( gettimeofday );
use Term::ReadKey;


# Global cli, soldebug and linux handlers
my %handles_g;

# Keep track of whether or not we have printed a '.' while waiting for the router
my $printedDot_g = 0;

# Don't modify anything outside of the User Code Start/End markers or
# it will be lost if the script's configuration is changed

my %graphId = ( "Queue" => 0, "Process" => 1, "Stats" => 2, "Rate" => 3);

my $queuetype = 0;
my $processtype = 1;
my $statstype = 2;
my $ratetype = 3;

my $xstartrange = " ";
my $xendrange   = " ";
#my $xstartrangeStr = " ";
#my $xendrangeStr   = " ";
#my $rangecmd;

my @queuecol   = (["Current",0],["Depth avg",1],["Depth max",2],["Lat avg",3],["Lat max",4]);
my @processcol = (["Success",0],["Failed",1],["Invokes",2],["Ave",3],["Max",4],["Min",5],["Total",6]);
my @statscol   = (["Current",0],["Min",1],["Max",2]);
my @ratecol    = (["Doc Ing",0],["Ack Ing",1],["Spl Ing",2],["Spl Egr",3],["Unspool",4],["Eg Ing",5],["Eg Egr",6],["Eg Ack",7]);

#my @queuecol = ("Success","Failed","Invokes","Ave","Max","Min");
#my @statscol = ("Success","Failed","Invokes","Ave","Max","Min");
#my @ratecol = ("Success","Failed","Invokes","Ave","Max","Min");

my @graphName = ("Queue", "Process", "Stats", "Rate");

my @thresholdArray;

$thresholdArray[0] = 0;
$thresholdArray[1] = 1;
$thresholdArray[2] = 0;
$thresholdArray[3] = 0;
  
my @columnArray;

$columnArray[0] = 4;
$columnArray[1] = 4;
$columnArray[2] = 1;
$columnArray[3] = 3;

my @displayArray;

$displayArray[0] = $args{queue};
$displayArray[1] = $args{process};
$displayArray[2] = $args{stats};
$displayArray[3] = $args{rate};

my @Plot;

my @displaySerie = ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
		  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
		  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
		  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]); 

my @displayThreshold = ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
		  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
		  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
		  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]); 

my @serieName;
my @serieNameMax;

# Holds the list of saved configs
my %savedConfigs_g;

# Call main - the start of the script
Main();

##############################################################################
## Main - Starting point for the script
##
##############################################################################
sub Main {
  my $routername = $args{router};
  my $file = $args{file};
  my $port = $args{port};

  $args{cfg_file} =~ s/^~/$ENV{HOME}/;


  
  if ($file ne "undefined") {
      # get the file directly
      print "Using supplied file $file to create the graph\n";
      system("cp $file /tmp/plotfile");
  } elsif ($routername ne "router") {
      print "Connecting to router <$routername> to create the graph\n";

      # Add code here - all arguments are available in the %args hash
      my $cmdType = "soldebug :conn 3 ";
      my $cmd ="adDumpProcessHistoryPlot";

      my $h = GetHandle($cmdType);
      if (!defined($h)) {
	  print "Failed to get a connection handle for $cmdType\n";
	  return;
      }

      #  print "$cmdType\n";
      #  print "$cmd\n";
      my $result = $h->send($cmd);
      #print "$result\n";
      #print index $result, "contains";

      print "\n";
      my $offset = index $result, "contains";
      #  print "$offset \n";
      print "";
      my $filename = substr $result, 0, $offset;
      Debug("filename is:  $filename",1);
      system("scp -P $port root\@$routername:/usr/sw/$filename /tmp/plotfile");

  } else {
      print " Router or filename must be specified. Exiting\n";
  }
  system("grep \"Queue:\" /tmp/plotfile | cut -d, -f1-2  | sort -t, -uk1 > /tmp/plotqueue");
  system("grep \"Process:\" /tmp/plotfile | cut -d, -f1-2  | sort -t, -uk1 > /tmp/plotprocess");
  system("grep \"Stats:\" /tmp/plotfile | cut -d, -f1-2  | sort -t, -uk1 > /tmp/plotstats");
  system("grep \"Rate:\" /tmp/plotfile | grep \"-\" -v | cut -d, -f2-10  | sort -t, -uk1 > /tmp/plotrate");

#  my $processPlot         = StartGnuplot();
#  my $queuePlot         = StartGnuplot();
#  my $statPlot         = StartGnuplot();

  my $queuegraph = $args{queue};
  my $processgraph = $args{process};
  my $statsgraph = $args{stats};
  my $rategraph = $args{rate};


#  if ($queuegraph) {
      $Plot[0] = StartGnuplot();
#  }
#  if ($processgraph) {
      $Plot[1] = StartGnuplot();
#  }
#  if ($statsgraph) {
      $Plot[2] = StartGnuplot();
#  }
  $Plot[3] = StartGnuplot();

  # load the current config
  LoadRuleFile($args{cfg_file}) if -r $args{cfg_file};

  while(1) {

      if ($displayArray[0]) {
	  RegenQueuePlot($Plot[0]);
      }
      if ($displayArray[1]) {
	  RegenProcessPlot($Plot[1]);
      }
      if ($displayArray[2]) {
	  RegenStatPlot($Plot[2]);
      }
      if ($displayArray[3]) {
	  RegenRatePlot($Plot[3]);
      }
    PrintPrompt();

    # Will get and process keystrokes and wait the interval time
    my $rc = GetInputAndWait();
  }



  Error('Add some code here', 1);
  Warn('Example warning - will be seen unless --quiet is specified', 1);
  Info('Example info - will be seen if --verbose is specified', 1);
  Debug('Example debug - will be seen if --debug is specified', 1);

} # Main #

##############################################################################
## RedrawGraphs - 
##
## This will redraw the selected graphs 
##
##############################################################################
sub RedrawGraphs {

      if ($displayArray[0]) {
	  RegenQueuePlot($Plot[0]);
      }
      if ($displayArray[1]) {
	  RegenProcessPlot($Plot[1]);
      }
      if ($displayArray[2]) {
	  RegenStatPlot($Plot[2]);
      }
      if ($displayArray[3]) {
	  RegenRatePlot($Plot[3]);
      }

}
##############################################################################
## GetInputAndWait - 
##
## This will wait the polling interval and process any keystrokes that are
## typed while waiting 
##
##############################################################################
sub GetInputAndWait {
  # my () = @_;

  ReadMode 4;
  my $char = ReadKey($args{interval});
  ReadMode 0;

  return if !defined $char;

  my $printPrompt = 1;
  if ($char =~ /t/i) {
    Threshold();
  }
  elsif ($char =~ /g/i) {
    DisplayData();
  }
  elsif ($char =~ /c/i) {
    SelectColumn();
  }
  elsif ($char =~ /h/i) {
    DisplaySerie();
  }
  elsif ($char =~ /d/i) {
    DeleteGraph();
  }
  elsif ($char =~ /f/i) {
    FocusGraph();
  }



  elsif ($char =~ /[q]/i) {
    print "quiting...\n";
    exit;
  }
  elsif ($char =~ /s/i) {
    SaveConfig();
  }
  elsif ($char =~ /l/i) {
    #LoadRuleFile($args{cfg_file}) if -r $args{cfg_file};
    LoadConfig();
    #return "reset";
  }
#  elsif ($char =~ /C/) {
#    ClearPlot();
#  }
#  elsif ($char =~ /n/) {
#    LearnStat();
#  }
  elsif ($char =~ /\?/) {
    PrintHelp();
  }
  else {
    $printPrompt = 0;
  }

  PrintPrompt() if $printPrompt;

} # GetInputAndWait #

##############################################################################
## SaveConfig - This will save the set of stats 
##
##############################################################################
sub SaveConfig {
  # my () = @_;

  while (1) {
    my @keys = keys %savedConfigs_g;
    my $size = @keys;
    if ($size > 0)
    {
	print "Some saved config exist, here are the values\n";
	foreach my $group (sort(keys(%savedConfigs_g)))
	{
	    my ($gname, $gtype) = split /_/,$group;
	    print "$gname \n";
	}
    }
    print "\n${BOLD}Enter name for this performance filter: ${NORMAL}";
    chomp(my $name = <STDIN>);
    $name =~ s/^\s*//;
    $name =~ s/\s*$//;


    my $type=0;
    my $serie=0;
    my $i=0;
    my $j=0;

#    for $type ( 0 .. 3 ) {
    
    $type = NumberedQuery("save following graph thresholds?",
                              [["Queue $displayArray[0]",0],
                               ["Process $displayArray[1]",1],
                               ["Stats $displayArray[2]",2],
                               ["Rate $displayArray[3]",3],
                               ["Exit",4]
                              ], 1);

    if ($displayArray[$type]) {
	$name .= "_$graphName[$type]";
	my @serielist;
	delete($savedConfigs_g{$name});
	for $i ( 0 .. $serieNameMax[$type]) {
	    if ($displaySerie[$type][$i] == 1){
		push( @{$savedConfigs_g{$name}}, "$serieName[$type][$i]_enabled ");
	    }
	    else {
		push( @{$savedConfigs_g{$name}}, "$serieName[$type][$i]_disabled ");
	    }
	}
	print @serielist
    }

    
#    my $s = \%selectedStats_g;
#    foreach my $stat (sort {$s->{$a}{index} <=> $s->{$b}{index}} (keys(%{$s}))) {
#      next if ($s->{$stat}{disable});
#      push(@{$savedConfigs_g{$name}}, "$stat:{axis:$s->{$stat}{axis}}");
#    }

    last;
  }

  #print Dumper \%selectedStats_g;
  #print Dumper \%savedConfigs_g;

  RewriteSavedFilters();

} # SaveConfig #

my @stats_g;

##############################################################################
## LoadConfig - Load one of the configured stat groups 
##
##############################################################################
sub LoadConfig {
  # my () = @_;

  my %menu = (title => "Configure filter groups",
              prompt => "Choose group"
      );

  my @keys = keys %savedConfigs_g;
  my $size = @keys;
  if ($size == 0)
  {
      print "No config has been saved yet\n";
      return;
  }
  
  foreach my $group (sort(keys(%savedConfigs_g))) {
    push(@{$menu{items}}, $group);
  }
  
  my $group = DoMenu(\%menu);

#  if (@stats_g && YOrN("Remove existing stats before adding these?")) {
#    RemoveAllStats();
#s  }

  ## Determine the type
  my ($groupid,$typename) = split /_/,$group;
  my $type=0;
#  my $serie=0;
#  my $i=0;
  my $i=0;
 for $type ( 0 .. 3 ) {
      if ( $typename eq $graphName[$type] ) {
	  for $i ( 0 .. $serieNameMax[$type]) {
	      foreach my $rule (@{$savedConfigs_g{$group}}) {
		  my ($name, $params) = split /_/,$rule;
		  $params =~ s/^\s+|\s+$//g;
		  my $currentname = $serieName[$type][$i];
		  # remove space at both end of string
		  $name =~ s/^\s+|\s+$//g;
		  $currentname =~ s/^\s+|\s+$//g;
		  if ($name eq $currentname){
		      if ($params eq 'enabled'){
			  $displaySerie[$type][$i] = 1;
		      }
		      else {
			  $displaySerie[$type][$i] = 2;
		      }
		  }
	      }
	  }
      }
  }
#  foreach my $stat (@{$savedConfigs_g{$group}}) {
#    my ($name, $params) = ($stat =~ /([\w\d\-\_\.]+):{([^}]*)}/);
#    my %params = split(/,|:/, $params);
#    AddStat($name, \%params);
#  }


} # LoadConfig #





##############################################################################
## RewriteSavedFilters - 
##
## Open the config file and substitute the existing saved groups for the
## current ones 
##
##############################################################################
sub RewriteSavedFilters {
  # my () = @_;

  my $section = "[SavedFilters]\n\n";

  foreach my $group (keys(%savedConfigs_g)) {
    $section .= "$group = " . join(",", @{$savedConfigs_g{$group}});
    $section .= "\n";
  }


  if (! -e $args{cfg_file}) {
    open(CFG, ">", $args{cfg_file}) || (Error("Failed to write to config file ($args{cfg_file}): $!") && return);
    print CFG $section;
    ##print CFG "section\n";
    close(CFG);
    return;
  }

  open(CFG, "<", $args{cfg_file}) || (Error("Failed to open the config file ($args{cfg_file}): $!") && return);
  my $cfg;
  while (my $l = <CFG>) {
    $cfg .= $l;
  }
  close(CFG);

  
  if ($cfg !~ /\[SavedFilters\]/) {
    $cfg .= "\n$section\n";
  }
  else {
    $cfg =~ s/(^|\n)\s*\[SavedFilters\](?:.|\n)*?((?:\s*\[[\w\s]+\])|\s*$)/$1$section$2/i;
  }

  open(CFG, ">", $args{cfg_file}) || (Error("Failed to write to config file ($args{cfg_file}): $!") && return);
  print CFG $cfg;
  close(CFG);

} # RewriteSavedFilters #


##############################################################################
## LoadRuleFile - 
##
## Parse the rules in the specified file and store them in the rules_g hash 
##
##############################################################################
sub LoadRuleFile {
  my ($file) = @_;

  open(IN, "<", $file) || Fatal("Can't open rule file $file: $!");

  my $section = "";
  while (my $line = <IN>) {
    next if $line =~ /^\s*#/ || $line =~ /^\s*$/;

    if ($line =~ /^\s*\[(\w+)\]/i) {
      $section = lc($1);
      next;
    }

    next if $section eq "";
    
    if ($section eq "rules") {
      # Parse the rule

    }
    elsif ($section eq "savedfilters") {
	my ($group, $rest) = ($line =~ /^\s*([\w\_\-\d\.\s]+?)\s*=\s*(.*?)\s*$/);
	#print "group  $group \n";
	#print "rest $rest \n";
	if (!defined($group) || !defined($rest)) {
	    Error("Malformed stat group definition: $line");
	    next;
	}
	my @savedRule;
	@savedRule = split(',',$rest);
	#print "*** @savedRule";
	$savedConfigs_g{$group} = \@savedRule;

    }
  }

  #print Dumper \%savedConfigs_g;
  #print Dumper \%rules_g;
  close(IN);

} # LoadRuleFile #




##############################################################################
## FocusGraph - toggle the display of a data graph
##
##############################################################################
sub FocusGraph {


    my $input=0;
    my $input2=0;
    my $column=0;
    my $i=0;
    my $exit=0;
    my $increment = 1000;

    while ($input != 1) {

	$input = NumberedQuery("Select Focus modificationthe Column?",
			       [["Exit",1],
				["Modify starting range",2],
				["Modify ending   range",3],
				["Enter  range",4],
			       ], 1);

	if ($input == 2 ) {
	    $input2 = 0;
	    while ($input2 != 1) {
		$input2 = NumberedQuery("Select Lower Range Modification?",
					[["Exit",1],
					 ["set Increment "   , 2],
					 ["Repeat Increment $increment"   ,3]
					], 1);
		if ($xstartrange == " ") {
		    $xstartrange =0;
		}
		if ($input2 == 2) {
		    chomp($increment = <STDIN>);
		}
		if ($input2 != 1){
		    $xstartrange += $increment;
		    SetPlotRanges();
		    RedrawGraphs();
		}
	    }
		
	}
	if ($input == 3 ) {
	    $input2 = 0;
	    while ($input2 != 1) {
		$input2 = NumberedQuery("Select Lower Range Modification?",
					[["Exit",1],
					 ["set Increment "   , 2],
					 ["Repeat Increment $increment"   ,3]
					], 1);
		if ($xendrange == " ") {
		    $xendrange =0;
		}
		if ($input2 == 2) {
		    chomp($increment = <STDIN>);
		}
		if ($input2 != 1){
		    $xendrange += $increment;;
		    SetPlotRanges();
		    RedrawGraphs();
		}
	    }
		
	}
	if ($input == 4 ) {
	    print "Enter Starting range";
	    chomp($xstartrange = <STDIN>);
	    print "Enter End range";
	    chomp($xendrange = <STDIN>);
	    
	    SetPlotRanges();
	    RedrawGraphs();
	}
    }

} #  FocusGraph #




##############################################################################
## SelectColumn - toggle the display of a data graph
##
##############################################################################
sub SelectColumn {


    my $type;
    my $column=0;
    my $i=0;
    $type = NumberedQuery("graph to Select the Column?",
                              [["Queue $displayArray[0]  Column selected @queuecol[$columnArray[0]]->[0]",0],
                               ["Process $displayArray[1] Column selected @processcol[$columnArray[1]]->[0]",1],
                               ["Stats $displayArray[2] Column selected @statscol[$columnArray[2]]->[0]",2],
                               ["Rate $displayArray[3] Column selected @ratecol[$columnArray[3]]->[0]",3],
                               ["Exit",4]
                              ], 1);


    if ($type < 4) {
#	foreach my $line ($serieName[$type]) {
#	    print "$line \n";
#	}

#	for $i ( 0 .. $serieNameMax[$type]) {
#	    $serielist[i] = "$serieName[$type][i] enable: $displaySerie[$type][i]";
#	}
	if ($type == $queuetype) {
	    $column = NumberedQuery("column to select?",
				   \@queuecol
				   , 2);
	}
	if ($type == $processtype) {
	    $column = NumberedQuery("column to select?",
				   \@processcol
				   , 2);
	}
	if ($type == $statstype) {
	    $column = NumberedQuery("column to select?",
				   \@statscol
				   , 2);
	}
	if ($type == $ratetype) {
	    $column = NumberedQuery("column to select?",
				   \@ratecol
				   , 2);
	}

	print " column selected  $column\n";
	$columnArray[$type] = $column;
	    
    }

} #  SelectColumn #

##############################################################################
## DisplaySerie - toggle the display of a data graph
##
##############################################################################
sub DisplaySerie {


    my $type;
    my $serie=0;
    my $i=0;

    $type = NumberedQuery("graph to modify the threshold?",
                              [["Queue $displayArray[0]",0],
                               ["Process $displayArray[1]",1],
                               ["Stats $displayArray[2]",2],
                               ["Rate $displayArray[3]",3],
                               ["Exit",4]
                              ], 1);

    if ($type < 4) {
#	foreach my $line ($serieName[$type]) {
#	    print "$line \n";
#	}

#	for $i ( 0 .. $serieNameMax[$type]) {
#	    $serielist[i] = "$serieName[$type][i] enable: $displaySerie[$type][i]";
#	}
	
	while ($serie <=$serieNameMax[$type]) {
	    my @serielist;
#	    print "Max value is $serieNameMax[$type]";
	    push( @serielist, ["Done filtering",$serieNameMax[$type]+1]);
#	    push( @serielist, ["filter range",$serieNameMax[$type]+1]);
	    for $i ( 0 .. $serieNameMax[$type]) {
		if ($displaySerie[$type][$i] == 1){
		    push( @serielist, ["enabled $serieName[$type][$i] ($displayThreshold[$type][$i]) ",$i]);
		}
		else {
		    push( @serielist, ["disabled                     $serieName[$type][$i] ($displayThreshold[$type][$i])",$i]);
		}
		    
#	    print " building list $serieName[$type][$i]\n";
	    }
	    $serie = NumberedQuery("serie to toggle?",
				   \@serielist
				   , 0);
	    print " respons from query $serie\n";
	    if ($serie <=$serieNameMax[$type]) {
		if ($displaySerie[$type][$serie] == 1){
		    
		    print " SETING To 2\n";
		    $displaySerie[$type][$serie] = 2;
		} elsif ($displaySerie[$type][$serie] == 2){
		    print " SETING To 1\n";
		    $displaySerie[$type][$serie] = 1;
		}
	    }
	}
	    
    }

} #  DisplaySerie #

##############################################################################
## SaveSerie - save a serie
##
##############################################################################
sub SaveSerie {


    my $type;
    my $serie=0;
    my $i=0;

    $type = NumberedQuery("save following graph thresholds?",
                              [["Queue $displayArray[0]",0],
                               ["Process $displayArray[1]",1],
                               ["Stats $displayArray[2]",2],
                               ["Rate $displayArray[3]",3],
                               ["Exit",4]
                              ], 1);

    if ($type < 4) {
	my @serielist;
	for $i ( 0 .. $serieNameMax[$type]) {
	    push( @serielist, ["enabled $serieName[$type][$i] $displaySerie[$type][$i]) "]);
	}
	print @serielist
    }
} #  SaveSerie #

##############################################################################
## Display - toggle the display of a data graph
##
##############################################################################
sub DisplayData {

    my $type;
    $type = NumberedQuery("graph to modify the threshold?",
                              [["Queue $displayArray[0]",0],
                               ["Process $displayArray[1]",1],
                               ["Stats $displayArray[2]",2],
                               ["Rate $displayArray[3]",3],
                               ["Exit",4]
                              ], 1);

    if ($type < 4) {

	if ($displayArray[$type]) {
	    print "Disable the display the $graphName[$type]";
	    $displayArray[$type] = 0;
	    #close($Plot[$type]);
	}
	else {
	    print "Enable the display the $graphName[$type]";
	    $displayArray[$type] = 1;
	    #$Plot[$type] = StartGnuplot();
	}
	    
    }

} # Threshold #

##############################################################################
## Threshold - Set threshold for graph
##
##############################################################################
sub Threshold {

    my $type;
    $type = NumberedQuery("graph to modify the threshold?",
                              [["Queue",0],
                               ["Process",1],
                               ["Stats",2]
                              ], 2);

    print "Enter threshold value for $graphName[$type] graph:  current = $thresholdArray[$type]\n";

    my $input = <STDIN>;


    $thresholdArray[$type] = $input;
    print "New threshold value for $graphName[$type] graph is  $thresholdArray[$type]\n";
    

} # Threshold #

##############################################################################
## NumberedQuery - Ask a question with a pick a number response. 
##
##############################################################################
sub NumberedQuery {
  my ($question, $numList, $default) = @_;

  while (1) {

    print "\n$BOLD$question$NORMAL\n";
  
    my $count = 1;
    my $defaultNum;
    foreach my $entry (@$numList) {
      print "  $count: $entry->[0]\n";
      if (defined $default && 
          (((defined $entry->[1]) && ($entry->[1] eq $default)) ||
           ($default eq $entry->[0]))) {
        $defaultNum = $count;
      }
      $count++;
    }
    
    print "";
    
    print "${BOLD}Enter number".($defaultNum ? " [$NORMAL$defaultNum$BOLD]: " : ": ");

    print $NORMAL;

    chomp(my $num = <STDIN>);

    if ($num eq "") {
      $num = $defaultNum || 0;
    }
    
    if ($num >= 1 && $num <= scalar(@$numList)) {
      if (defined $numList->[$num-1][1]) {
        return($numList->[$num-1][1]);
      }
      return($numList->[$num-1][0]);
    }

    print "Invalid value!\n";

  }

} # NumberedQuery #



##############################################################################
## PrintPrompt - Print out the prompt 
##
##############################################################################
sub PrintPrompt {
  # my () = @_;

  print "(${BOLD}t${NORMAL})hreshold (${BOLD}h${NORMAL})ide data (${BOLD}s${NORMAL})ave (${BOLD}l${NORMAL})oad (${BOLD}c${NORMAL})olumn (${BOLD}g${NORMAL})raph  (${BOLD}f${NORMAL})ocus  (${BOLD}q${NORMAL})uit  (${BOLD}?${NORMAL}) help\n";

} # PrintPrompt #

##############################################################################
## DoMenu - 
##
##############################################################################
sub DoMenu {
  my ($options) = @_;

  my $val;
  while (1) {
    print "\n";
    print "${BOLD}$options->{title}${NORMAL}\n" if $options->{title};
    my $idx = 1;
    foreach my $item (@{$options->{items}}) {
      if (ref($item) eq "HASH") {
        printf("  %2d: %s\n", $idx, $item->{name});
      }
      else {
        printf("  %2d: %s\n", $idx, $item);
      }
      $idx++;
    }
    if ($options->{prompt}) {
      print "${BOLD}$options->{prompt}:${NORMAL} ";
    }
    else {
      print "${BOLD}Select item:${NORMAL} ";
    }

    $val = <STDIN>;
    if ($val > 0 &&
        $val <= @{$options->{items}}) {
      last;
    }
    print "${BOLD}Invalid value${NORMAL}\n";
  }
  
  $val--;
  my $selected;
  if (ref($options->{items}[$val]) eq "HASH") {
    if (defined($options->{items}[$val]{menu})) {
      return DoMenu($options->{items}[$val]{menu});
    }
    $selected = defined($options->{items}[$val]{value}) ?
        $options->{items}[$val]{value} : $options->{items}[$val]{name};
  }
  else {
    $selected = $options->{items}[$val];
  }

  return ($selected, $val) if wantarray;
  return $selected;

} # DoMenu #





##############################################################################
## PrintHelp - 
##
##############################################################################
sub PrintHelp {

  print "
rs-plot-ad-perf

rs-prof plot will gather on set of profiler statistic from the router and plot them using gnuplot.
Interactively the user can fine tune the graph to get the desired result:

t - modify the graph thresholds for display
h - hide specific dats lines
c - chose the graph column to display
s - show or remove a specific graph
f - modfiy the range of time to display
q - quit
help - want you do not know

Saved configurationws will appear in ~/.rs-prof-plot.  That file can also
be augmented with additional stat retrieval rules in order to add
custom stats to rs-plot.  These additional rules must appear under the
[Rules] section of the config file.  
";


} # PrintHelp #

##############################################################################
## RegenStatPlot - 
##
##############################################################################
sub RegenStatPlot {
  my ($plot) = @_;

  my $cmd = "plot ";
  my $label;

  my $columnfield =  $columnArray[$statstype]+2;

  my $display = 0;

  print " Performing RegenStatPlot with column @statscol[$columnArray[$statstype]]->[0]\n";

  open( my $stat, "<", "/tmp/plotstats") or die "Could not open /tmp/plotstat\n";
  my $statid = 0;
  my @statname;
  while (my $line = <$stat>) {
      chomp($label = substr $line, 8);
      $statname[$statid] = $label;
      Debug("create list for $label",1);
     system("grep \"$label\" /tmp/plotfile | cut -d, -f3-6 > /tmp/plotstat_$statid");

      system("cut -d, -f$columnfield /tmp/plotstat_$statid > /tmp/plotstat_T_$statid");

      open( my $statfile, "<", "//tmp/plotstat_T_$statid") or die "Could not open /tmp/plotstat_T_$statid\n";
      
      while (my $line2 = <$statfile>) {
	  if ( $line2 >= $thresholdArray[$statstype]) {
	      $display += 1;
	  }
      }    

#      if ( $display > 0 )
#      {
	  Debug("Found $display line above threshold $thresholdArray[$statstype] for file /tmp/plotstat_$statid",1);
	  $cmd .= "\'/tmp/plotstat_$statid\' using 1:$columnfield title \'$label ($statid)\' with line axes x1y1,";
#      }
      $displayThreshold[$statstype][$statid] = $display;
      $display = 0;
      $statid  = $statid + 1;
  }

  $serieNameMax[$statstype] = $statid -1;

  
  $cmd =~ s/,$//;
  Debug( "plotcmd is $cmd",1); 
  print $plot "set title \"Stats Graph, Column Displayed: @statscol[$columnArray[$statstype]]->[0]\"\n";
   print $plot "$cmd\n";


} # RegenPlot #


##############################################################################
## RegenProcessPlot - 
##
##############################################################################
sub RegenProcessPlot {
  my ($plot) = @_;

  my $cmd = "plot ";
  my $label;

  my $columnfield =  $columnArray[$processtype]+2;

  print " Performing RegenProcessPlot with column @processcol[$columnArray[$processtype]]->[0]\n";
  open( my $process, "<", "/tmp/plotprocess") or die "Could not open /tmp/plotprocess\n";
  my $processid = 0;
  my @processname;
  my $display = 0;
  while (my $line = <$process>) {
      chomp($label = substr $line, 9);
      $processname[$processid] = $label;
      $serieName[$processtype][$processid] = $label;
      Debug("create list for $label",1);
      system("grep \"$label\" /tmp/plotfile | cut -d, -f3-10 > /tmp/plotprocess_$processid");
      #print "cut -d, -f$columnfield /tmp/plotprocess_$processid > /tmp/plotprocess_T_$processid\n";
      Debug("cut -d, -f$columnfield /tmp/plotprocess_$processid > /tmp/plotprocess_T_$processid",1);
      system("cut -d, -f$columnfield /tmp/plotprocess_$processid > /tmp/plotprocess_T_$processid");

      open( my $processfile, "<", "//tmp/plotprocess_T_$processid") or die "Could not open /tmp/plotprocess_T_$processid\n";
      
      while (my $line2 = <$processfile>) {
	  if ( $line2 >= $thresholdArray[$processtype]) {
	      $display += 1;
	  }
      }    
	 
      if ( $display > 0 )
      {
	  Debug("Found $display line above threshold $thresholdArray[$processtype] for file /tmp/plotprocess_$processid",1);
	  if ( $displaySerie[$processtype][$processid] == 0) {# 0 = undefined
	      $displaySerie[$processtype][$processid] = 1; # on
	  }
	  if ($displaySerie[$processtype][$processid] == 1) {
	      $cmd .= "\'/tmp/plotprocess_$processid\' using 1:$columnfield title \'$label ($processid)\' with linespoint axes x1y1,";
	  }
      }
      else {
	  if ( $displaySerie[$processtype][$processid] == 0) {
	      $displaySerie[$processtype][$processid] = 2; # off
	  }
      }
      $displayThreshold[$processtype][$processid] = $display;
      $display = 0;
      $processid  = $processid + 1;
  }
  $serieNameMax[$processtype] = $processid -1;
  
  
  $cmd =~ s/,$//;
  Debug( "plotcmd is $cmd",1); 
  print $plot "set title \"Process Graph, Column Displayed: @processcol[$columnArray[$processtype]]->[0]\"\n";
  print $plot "$cmd\n";


} # RegenPlot #


##############################################################################
## RegenQeueuPlot - 
##
##############################################################################
sub RegenQueuePlot {
  my ($plot) = @_;

  my $cmd = "plot ";
  my $label;


  my $columnfield =  $columnArray[$queuetype]+2;
  print " Performing RegenQueuePlot with column @queuecol[$columnArray[$queuetype]]->[0]\n";
  open( my $queue, "<", "/tmp/plotqueue") or die "Could not open /tmp/plotqueue\n";
  my $queueid = 0;
  my @queuename;
  my $display = 0;

  while (my $line = <$queue>) {
      chomp($label = substr $line, 9);
      $queuename[$queueid] = $label;
      Debug("create list for $label",1);
      system("grep \"$label\" /tmp/plotfile | cut -d, -f3-9 > /tmp/plotqueue_$queueid");

      system("cut -d, -f$columnfield /tmp/plotqueue_$queueid > /tmp/plotqueue_T_$queueid");
      open( my $queuefile, "<", "/tmp/plotqueue_T_$queueid") or die "Could not open /tmp/plotqueue_T_$queueid\n";
      
      while (my $line2 = <$queuefile>) {
	  if ( $line2 >= $thresholdArray[$queuetype]) {
	      $display += 1;
	  }
      }    
	 
      if ( $display > 0 )
      {
	  Debug("Found $display line above threshold $thresholdArray[$queuetype] for file /tmp/plotqueue_$queueid",1);
	  $cmd .= "\'/tmp/plotqueue_$queueid\' using 1:$columnfield title \'$label ($queueid)\' with line axes x1y1,";
      }
      $displayThreshold[$queuetype][$queueid] = $display;
      $display = 0;
      $queueid  = $queueid + 1;
  }

  
  $cmd =~ s/,$//;
  Debug( "plotcmd is $cmd",1); 
  print $plot "set title \"Queue Graph, Column Displayed: @queuecol[$columnArray[$queuetype]]->[0]\"\n";
  print $plot "$cmd\n";


} # RegenQueuePlot #

##############################################################################
## RegenRatePlot - 
##
##############################################################################
sub RegenRatePlot {
  my ($plot) = @_;

  my $cmd = "plot ";
  my $label;

  my $columnfield =  2;

  print " Performing RegenRatePlot \n";
  my $rateid = 0;
  my @ratename;
  my $display = 0;
  while ($rateid < 8) {
      $columnfield =  $rateid +2;
      $label = $ratecol[$rateid]->[0];
      $ratename[$rateid] = $label;
      $serieName[$ratetype][$rateid] = $label;
      Debug("create list for $label",1);
	 
      if ( $displaySerie[$ratetype][$rateid] == 0) {# 0 = undefined
	  $displaySerie[$ratetype][$rateid] = 1; # on
      }
      if ($displaySerie[$ratetype][$rateid] == 1) {
	  $cmd .= "\'/tmp/plotrate\' using 1:$columnfield title \'$label \' with line axes x1y1,";
      }

      $display = 0;
      $rateid  = $rateid + 1;
  }
  $serieNameMax[$ratetype] = $rateid -1;
  
  
  $cmd =~ s/,$//;
  Debug( "plotcmd is $cmd",1); 
  print $plot "set title \"Rate Graph \n";
  print $plot "$cmd\n";


} # RegenPlot #
sub SetPlotRanges {
    print "set xrange [$xstartrange:$xendrange]\n";
    SetPlotRange($Plot[0]);
    SetPlotRange($Plot[1]);
    SetPlotRange($Plot[2]);
    SetPlotRange($Plot[3]);
}

sub SetPlotRange {
  my ($plot) = @_;

  print $plot "set xrange [$xstartrange:$xendrange]\n";
  
}
##############################################################################
## StartGnuplot - 
##
##############################################################################
sub StartGnuplot {

#  open my $olderr, ">&STDERR";
#  close(STDERR);
#  open(STDERR, ">", "/dev/null");




  my $plot;
  open($plot, "| gnuplot -noraise -persist >& /dev/null") || Fatal("Failed to start gnuplot: $!");
  $plot->autoflush;
  print $plot "set xlabel \"milliseconds\"";
  print $plot "set yrange [0:]\n";
  print $plot "set y2range [0:]\n";
  print $plot "set y2tics\n";
  print $plot "set grid x y\n";
  
#  open STDERR, ">&", $olderr;

  return $plot;

} # StartGnuplot #

##############################################################################
## GetHandle - 
##
## Return the requested handle type and create a session for it if it hasn't
## already been created 
##
##############################################################################
sub GetHandle {
  my ($type) = @_;
  my $lastDotTime = 0;

  if (!defined($handles_g{$type})) {

    my $actualType = $type;
    my $connStr;

    if ($actualType =~ /soldebug/) {
      $actualType = "soldebug";
      $connStr    = $type;
      $connStr    =~ s/^.*?:/:/g;
    }

    my $exp = new Solace::Expect(router => $args{router},
                                 type => $actualType,
                                 debug => $args{debug},
				 timeout => 10,
                                 log_stdout => $args{debug}) || 
                                     Fatal("Failed to create expect session of type $type");
    my $rc = $exp->connect();

    if (!defined($rc)) {
      my $t = time();
      if ($t - $lastDotTime > 5) {
        print ".";
        $printedDot_g = 1;
        $lastDotTime  = $t;
      }
      return undef;
    }
    elsif ($printedDot_g) {
      print "\n";
      PrintPrompt();
      $printedDot_g = 0;
    }

    if ($connStr) {
      $exp->send($connStr);
    }

    $handles_g{$type} = $exp;

  }

  return $handles_g{$type};

} # GetHandle #


##############################################################################
## CloseHandle - Close the handle for the specified type 
##
##############################################################################
sub CloseHandle {
  my ($type) = @_;

  delete($handles_g{$type});

} # CloseHandle #



##--User Code End--##



##############################################################################
## ParseArgs - Parse the command line arguments
##
##############################################################################
sub ParseArgs {
  
  # Options Parsing
  @allArgs = @ARGV;

  my %defaultArgs = %args;
  %args = ();

  # Converts position arguments to names
  my @posToName = (
              'router',
  );

  # Converts position arguments to names
  my @posToType = (
              'string',
  );

  # All required arguments
  my %requiredArgs = (
  );

  # All enum arguments
  my %enumArgs = (
  );

  # Cross ref of perl version of args to command line version
  my %perlToCmdArg = (
                       'router' => 'router',
                       'file' => 'file',
                       'port' => 'port',
                       'queue' => 'queue',
                       'process' => 'process',
                       'stats' => 'stats',
                       'rate' => 'rate',
                       'column' => 'column',
                       'threshold' => 'threshold',
                       'debug' => 'debug',
                       'gen_completion' => 'gen-completion',
                       'help' => 'help',
                       'interactive' => 'interactive',
                       'quiet' => 'quiet',
                       'short_help' => 'short-help',
                       'tiny_help' => 'tiny-help',
                       'verbose' => 'verbose',
  );


  LearnArgsFromConfFile();

  my $result = GetOptions (
                           'file=s' => \$args{file},
                           'port=o' => \$args{port},
                           'queue' => \$args{queue},
                           'process!' => \$args{process},
                           'stats' => \$args{stats},
                           'rate' => \$args{rate},
                           'column=o' => \$args{column},
                           'threshold=o' => \$args{threshold},
                           'debug' => \$args{debug},
                           'gen-completion' => \$args{gen_completion},
                           'help' => \$args{help},
                           'interactive' => \$args{interactive},
                           'quiet' => \$args{quiet},
                           'short-help' => \$args{short_help},
                           'tiny-help' => \$args{tiny_help},
                           'verbose' => \$args{verbose},
  );

  if (!$result) { exit 1; }

  # Positional argument processing

  my $posIdx = 0;
  while (@ARGV) {
    last if $posIdx >= 1;
  
    $args{$posToName[$posIdx]} = shift @ARGV;
    if ($posToType[$posIdx] eq 'integer') {
      $args{$posToName[$posIdx]} = 
         StrToNum($args{$posToName[$posIdx]}, "Invalid argument, failed to convert $args{$posToName[$posIdx]} to number");
    }
    delete $requiredArgs{$posToName[$posIdx]};
    $posIdx++;
  }

  @remainingArgs = @ARGV;
  @parsedArgs = @allArgs[0..(scalar(@allArgs)-scalar(@remainingArgs)-1)];

  Fatal("${BOLDr}Unrecognized argument(s):$NORMAL " . join(' ', @ARGV)) if $#ARGV > -1;

  foreach my $arg (keys(%args)) {
    $parsedArgs{$arg} = 1 if defined $args{$arg};
  }

  foreach my $arg (keys(%defaultArgs)) {
    $args{$arg} = $defaultArgs{$arg} if !defined $args{$arg};
  }

  # Standard option processing

  if ($args{gen_completion}) {
    print "--file --queue --process --stats --rate --column --threshold --debug --help --interactive --quiet --short-help --tiny-help --verbose ";
    exit 1;
  }

  if ($args{help}) {
    pod2usage(-verbose => 2);    
    exit 1;
  }
  if ($args{short_help}) {
    pod2usage(-verbose => 1);
    exit 1;
  }
  if ($args{tiny_help}) {
    my $info = GetArgInfo();
    print "$info->{Name} - $info->{ShortDescription}\n";
    exit 1;
  }

  my $showCmdLine = 0;
  if ($args{interactive}) {
    PromptForArgs(1, %args);
    $showCmdLine = 1;
  }
  
  # Check for missing required params
  foreach my $key (keys(%requiredArgs)) {
    if (defined $args{$key}) {
      delete $requiredArgs{$key};
    }
  }
  if (scalar(keys(%requiredArgs)) > 0) {
    print "\nMissing some required parameters\n";
    PromptForArgs(1, %requiredArgs);
    $showCmdLine = 1;
  }
  
  # Check that enums have valid values
  my $argInfo = GetArgInfo();
  foreach my $arg (keys(%enumArgs)) {
    if (defined $args{$arg}) {
      if (not defined $enumArgs{$arg}{$args{$arg}}) {
        print "\nInvalid value for argument $arg.  Valid values are:\n";
        foreach my $value (keys(%{$enumArgs{$arg}})) {
          print "  $value\n";
        }
        exit 1;
      }
    }
  }
  
  if ($showCmdLine) {
    # Output the command line for this
    DisplayCommandLine();
  }

} # ParseArgs #

##############################################################################
## PromptForArgs - Will ask the user for values for various arguments
##
## skipAutoArgs: When true, it will not prompt for --interactive, --debug,
##               --quiet, --verbose or --help
##
##############################################################################
sub PromptForArgs {
  my ($skipAutoArgs, %argsForPrompting) = @_;
  my $argInfo = GetArgInfo();
  
  print "\nInteractive Input:\n\n";
  foreach my $arg (@{$argInfo->{Args}}) {
    my $name = $arg->{Name};
    my $perlName = $arg->{PerlName};
    if (not exists $argsForPrompting{$perlName}) {
      next;
    }
    if ($skipAutoArgs && 
        ($name =~ /^(debug|interactive|quiet|verbose|help|gen-completion)$/)) {
      next;
    }
    my $desc = $arg->{Description};
    my $space = " " x (length($name) + 3);
    $desc =~ s/(.{1,75 - length($name)})(?:\s|$|\n)/$1\n$space/g;
    my $prompt = "\n$BOLD$name$NORMAL - $arg->{Description}";
    my $default = '';
    my $defVal = '';
    if (defined $args{$perlName}) {
      $default = " [$args{$perlName}]";
      $defVal = $args{$perlName};
    }
    elsif ($arg->{Default}) {
      $default = " [$arg->{Default}]";
      $defVal = $arg->{Default};
    }
    while (1) {
      if ($arg->{ValType} eq 'boolean') {
        print $prompt . "\nEnter value for flag (undef, 0 or 1)$default: ";
      }
      elsif ($arg->{ValType} =~ /integer|float/) {
        print $prompt . "\nEnter numeric value$default: ";
      }
      elsif ($arg->{ValType} eq 'enum') {
        print $prompt . "\nSelect value: ";
      }
      else {
        print $prompt . "\nEnter value$default: ";
      }
      my $response;
      if ($arg->{ValType} eq 'enum') {
        print "\n";
        $default = '';
        my $num = 1;
        my $defaultNum;
        foreach my $val (@{$arg->{EnumList}}) {
          print "  $num: $val\n";
          if ($val eq $defVal) {
            $default = "[$num]";
            $defaultNum = $num;
          }
          $num++;
        }
        while (1) {
          print "Select number$default: "; 
          chomp($response = <STDIN>);
          if ($response eq '') {
            $response = defined $defaultNum ? $defaultNum : 0;
          }
          if ($response >= 1 &&
              $response <= scalar(@{$arg->{EnumList}})) {
            $response = $arg->{EnumList}[$response-1];
            last;
          }
          print "Invalid selection - try again\n";
        }
      }
      else {
        chomp($response = <STDIN>);
      }
      if ($arg->{Required} && 
          (not defined $args{$perlName}) &&
          $response eq '') {
        print "You must enter a value for this argument\n";
      }
      else {
        if ($response eq '' && 
            defined $args{$perlName}) {
          # Keep the same value
        }
        elsif ($response eq '' && 
               defined $arg->{Default}) {
          $args{$perlName} = $arg->{Default};
        }
        else {
          if ($arg->{ValType} eq 'integer') {
            $args{$perlName} =
              StrToNum($response, "Failed to convert $response to number");
          }
          else {
            $args{$perlName} = $response;
          }
        }
        if (($arg->{ValType} eq 'boolean') && 
            (($args{$perlName} eq 'undef') || ($args{$perlName}) eq ''))  {
          $args{$perlName} = undef;
        }
        last;
      }
    }
  }

}



##############################################################################
## LearnArgsFromConfFile - This will open the appropriate .conf file to get
##                       additional arguments
##
##############################################################################
sub LearnArgsFromConfFile {
  my $homeDir;
  if (exists $ENV{'HOME'}) {
    $homeDir = $ENV{'HOME'};
  } else {
    # Some flavour of Windows? Try this:
    $homeDir = $ENV{'USERPROFILE'};
  }
  return if !(-e "$homeDir");
  return if !(-e "$homeDir/.scripts");

  my $conf = "$homeDir/.scripts/prof-plot.conf";
  return if !(-e $conf);

  # The file exists - suck it in and parse out the goodness
  open(IN, $conf) || return;
  my @data = <IN>;
  close(IN);

  my $section = "";
  my $quiet = 0;
  foreach my $line (@data) {
    if ($line =~ /^\s*\[([^\]]+)\]/) {
      $section = $1;
    }
    elsif ($section =~ /^(args)|(command-line-args)|(cmd-line-args)|(cmdline-args)/i || $section eq "") {
      if ($line =~ /^\s*([\w\-\_\d]+)\s*=\s*([^\n\s\#\;]+)/) {
        my $arg = $1;
        my $val = $2;
        print "Defaulting argument --$1 to $2 from .conf file\n" unless $quiet;
        # Put the arg at the head of the arg list
        unshift(@ARGV, "--$arg=$val");
      }
      elsif ($line =~ /^\s*([\w\-\_\d]+)\s*$/) {
        my $arg = $1;
        print "Defaulting flag --$1 to on from .conf file\n" unless $quiet;
        # Put the arg at the head of the arg list
        unshift(@ARGV, "--$arg");
      }
    }
    elsif ($section =~ /^global-?settings/i) {
      if ($line =~ /^\s*([\w\-\_\d]+)\s*=\s*([^\n\s\#\;]+)/) {
        my $arg = $1;
        my $val = $2;
        if (lc($arg) eq "quiet") {
          $quiet = $val;
          unshift(@ARGV, "--quiet") if $val;
        }
      }
    }
  }
  
} # LearnArgsFromConfFile


##############################################################################
## GetArgInfo - This will return all the script information in perl
##              struct form.
##
##############################################################################
sub GetArgInfo {

  my $cfgInfo = {
             'SuperScriptRevision' => '5740',
             'ShortDescription' => 'Plot the output of AD CPU profiler',
             'ParsingType' => 'unordered',
             'Description' => 'Plot the output from the AD Profiler Tool: compile with AD_PROFILE_HISTORY enabled in adCmnLogging.hpp',
             'Name' => 'rs-plot-ad-perf',
             'Args' => [
                         {
                           'Type' => 'positional',
                           'Default' => 'router',
                           'Required' => 0,
                           'ValType' => 'string',
                           'Name' => 'router',
                           'Description' => 'Name of router where profiler output is present',
                           'PerlName' => 'router'
                         },
                         {
                           'Type' => 'named',
                           'Default' => 'undefined',
                           'Required' => 0,
                           'ValType' => 'string',
                           'Description' => 'file to use for data',
                           'Name' => 'file',
                           'PerlName' => 'file'
                         },
                         {
                           'Type' => 'named',
                           'Default' => '2222',
                           'Required' => 0,
                           'ValType' => 'string',
                           'Description' => 'port to use to access host',
                           'Name' => 'port',
                           'PerlName' => 'port'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Default' => 0,
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'display the queue graph',
                           'Name' => 'queue',
                           'PerlName' => 'queue'
                         },
                         {
                           'AllowNo' => 1,
                           'Type' => 'named',
                           'Default' => 1,
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'process graph to be displayed',
                           'Name' => 'process',
                           'PerlName' => 'process'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Default' => 0,
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'display the stats graph',
                           'Name' => 'stats',
                           'PerlName' => 'stats'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Default' => 0,
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'display the rate graph',
                           'Name' => 'rate',
                           'PerlName' => 'rate'
                         },
                         {
                           'Type' => 'named',
                           'Default' => '5',
                           'Required' => 0,
                           'ValType' => 'integer',
                           'Description' => 'column to display in the graph',
                           'Name' => 'column',
                           'PerlName' => 'column'
                         },
                         {
                           'Type' => 'named',
                           'Default' => '1',
                           'Required' => 0,
                           'ValType' => 'integer',
                           'Description' => 'threshold to achieve before a stat series is diplayed',
                           'Name' => 'threshold',
                           'PerlName' => 'threshold'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Turn on all debug output.',
                           'Name' => 'debug',
                           'PerlName' => 'debug'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Prints out completion info for the parameters',
                           'Name' => 'gen-completion',
                           'PerlName' => 'gen_completion'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out usage info for this script',
                           'Name' => 'help',
                           'PerlName' => 'help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Query the user for values for each of the arguments, providing help for each.  This will print out the appropriate command line for future reference before executing the script.',
                           'Name' => 'interactive',
                           'PerlName' => 'interactive'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Reduce the amount of output to the bare minimum.',
                           'Name' => 'quiet',
                           'PerlName' => 'quiet'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out usage summary for this script',
                           'Name' => 'short-help',
                           'PerlName' => 'short_help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out one line description for this script',
                           'Name' => 'tiny-help',
                           'PerlName' => 'tiny_help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out more user-level output',
                           'Name' => 'verbose',
                           'PerlName' => 'verbose'
                         }
                       ],
             'PositionalListIdx' => undef
           };

  return $cfgInfo;

} # GetArgInfo


##############################################################################
## DisplayCommandLine - This will print out the command line for the
##                      current arguments
##
##############################################################################
sub DisplayCommandLine {

  my $argInfo = GetArgInfo();

  # my $output = "$argInfo->{Name} ";
  my $output = "$0 ";
  my $positional = '';

  foreach my $arg (@{$argInfo->{Args}}) {
    my $name = $arg->{Name};
    my $perlName = $arg->{PerlName};
    if (not defined $args{$perlName}) {
      next;
    }
    if (defined $arg->{Default} && 
        $args{$perlName} eq $arg->{Default}) {
      next;
    }
    if ($perlName eq 'interactive') {
      next;
    }

    my $value = $args{$perlName};
    if ($value =~ /\s/) {
      $value = "'$value'";
    }
    
    if ($arg->{Type} eq 'named') {
      if ($arg->{ValType} eq 'boolean') {
        if (defined $args{$perlName}) {
          if ($args{$perlName} == 0) {
            $output .= "--no-$name ";
          }
          else {
            $output .= "--$name ";
          }
        }
      }
      else {
        $output .= "--$name=$value ";
      }
    }
    else {
      if (ref $value eq 'ARRAY') {
        if (scalar(@{$value} > 1) || $value->[0] ne '') {
          $positional .= "@{$value} ";
        }
      }
      else {
        $positional .= "$value ";
      }
    }

  }
  
  print "Command line:\n";
  print "$output$positional\n\n";
  # `history -s $output$positional`;

} # DisplayCommandLine #


##############################################################################
## Log - Handle output messaging
##
##############################################################################
sub Log {
  my ($level, $message, $addCaller, $opts) = @_;

  return 0 if $level eq 'DEBUG' && ($args{quiet} || !$args{debug});
  return 0 if $level eq 'INFO'  && ($args{quiet} || (!$args{debug} && !$args{verbose}));
  return 0 if $level eq 'WARN'  && $args{quiet};

  print("$level: ") if $level ne 'MSG' || $addCaller;
  if ($addCaller) {
    my @caller = caller(1);
    $caller[1] =~  s/^.*\///;
    print("$caller[1]:$caller[2]: ");
  }
  print("$message\n");

  exit 1 if $level eq 'FATAL';

} # Log #

 
sub Fatal { Log('FATAL', @_) };
sub Error { Log('ERROR', @_) };
sub Warn  { Log('WARN',  @_) };
sub Info  { Log('INFO',  @_) };
sub Debug { Log('DEBUG', @_) };
sub Msg   { Log('MSG',   @_) };



##############################################################################
## StrToNum - Convert strings into numbers
##
##############################################################################
sub StrToNum {
  my ($string, $failMsg) = @_;

  Fatal($failMsg) if $string !~ 
      /^([-+]?_*[1-9][0-9_]*  |
         0x_*[0-9a-f][0-9a-f_]* |
         0b_*[01][01_]*         |
         0[0-7_]*)$
      /xi;

  ($string) = ($string =~ /(.*)/);
  my $num = eval($string);
  
  Fatal($@) if $@;
  return $num;

} # StrToNum #


 

__END__

=head1 NAME

rs-plot-ad-perf

=head1 DESCRIPTION

Plot the output from the AD Profiler Tool: compile with AD_PROFILE_HISTORY enabled in adCmnLogging.hpp, reset the profiler information with soldebug, conn: 3 adClearAll


=head1 OPTIONS

rs-plot-ad-perf [OPTIONS] [router] 

Where:

=over

=item router (string)

Name of router to extract profiler input
[Default: router]

=item --file=<string>

file to use for data
[Default: undefined]

=item --port

port to access the router

=item --queue

display the queue graph

=item --process or --no-process

process graph to be displayed
[Default: 1]

=item --stats

display the stats graph

=item --rate

display the rate graph

=item --column=<integer>

column to display in the graph
[Default: 5]

=item --threshold=<integer>

threshold to achieve before a stat series is diplayed
[Default: 1]

=item --interactive

Query the user for values for each of the arguments, providing help for each.  This will print out the appropriate command line for future reference before executing the script.

=item --help, --short-help, --tiny-help

Display various levels of usage information

=item --quiet, --verbose, --debug

Control the amount of information printed during execution

=back

