#!/usr/bin/perl
#
# Script: rs-vm-config-group
#
# 
# 
#
# The framework of the script was autogenerated by version 7505 of
# /opt/soldev/devtools/bin/super-script.
#
#############################################################################


use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;
use Pod::Usage;

use constant BOLD    => "\e[1m";
use constant NORMAL  => "\e[0m";
my $BOLD   = BOLD;
my $NORMAL = NORMAL;
my $BOLDr  = "\e[31m\e[1m";  # Red
my $BOLDg  = "\e[32m\e[1m";  # Green


# Main hash - all the argument values will be in here after parsing
my %args = (
            primary => undef,
            backup => undef,
            monitor => '',
            tls => '0',
            message_spool => '0',
            config_sync => '0',
            prompt => '1',
            debug => undef,
            gen_completion => undef,
            help => undef,
            interactive => undef,
            quiet => undef,
            short_help => undef,
            tiny_help => undef,
            verbose => undef,
);

# Arrays to hold the parsed and unparsed args
my @remainingArgs;
my @allArgs;
my @parsedArgs;
my %parsedArgs;

ParseArgs();

##--User Code Start--##

# Don't modify anything outside of the User Code Start/End markers or
# it will be lost if the script's configuration is changed

use FindBin;
use lib "$FindBin::Bin/../../../lib/perl";
use lib "$FindBin::Bin/../lib/perl";
use lib "/opt/cvsdirs/charvey/devtools/lib/perl";  # delete me!
use Solace::Simple;
use File::Basename;

# Call main - the start of the script
Main();

sub add100ToIp
{
    my $ipStr = $_[0];
    my @octets = split(/\./, $ipStr);
    $octets[3] += 100;
    my $ret = "$octets[0]." . "$octets[1]." . "$octets[2]." . "$octets[3]";
    return $ret;
}

##############################################################################
## Main - Starting point for the script
##
##############################################################################
sub Main {

    my $rtrP = connectToRouter($args{primary});
    my $rtrB = connectToRouter($args{backup});

    ## Monitor is optional.
    my $rtrM;
    if ($args{monitor}) {
	$rtrM = connectToRouter($args{monitor});
    }

    my $isConsul = 0;
    if (!(basename($rtrP->linux("which consul")) eq basename($rtrB->linux("which consul")))) {
        print "Not all routers appear to have either consul or pacemaker";
        exit 1;
    }
    if ($rtrM) {
	if (!(basename($rtrP->linux("which consul")) eq basename($rtrM->linux("which consul")))) {
	    print "Not all routers appear to have either consul or pacemaker";
	    exit 1;
	}
    }
    my $tmp = $rtrP->linux("which consul");
    chomp($tmp);
    if (($tmp eq "/usr/bin/consul") ||
        ($tmp eq "/bin/consul")) {
        $isConsul = 1;
    }

    my $lastRes = $rtrP->cli('show router-name');
    my ($rtrPname) = ($lastRes =~ /Router Name: +(\S*).*/);
    $lastRes = $rtrB->cli('show router-name');
    my ($rtrBname) = ($lastRes =~ /Router Name: +(\S*).*/);
    my $rtrMname = "fakeMonitor";
    if ($rtrM) {
	$lastRes = $rtrM->cli('show router-name');
	($rtrMname) = ($lastRes =~ /Router Name: +(\S*).*/);
    }
    $lastRes = $rtrP->cli('show ip vrf management');
    my ($rtrPip) = ($lastRes =~ /.*static +([\d.]+)/);
    $lastRes = $rtrB->cli('show ip vrf management');
    my ($rtrBip) = ($lastRes =~ /.*static +([\d.]+)/);
    my $rtrMip = "0.0.0.1";
    if ($rtrM) {
	$lastRes = $rtrM->cli('show ip vrf management');
	($rtrMip) = ($lastRes =~ /.*static +([\d.]+)/);
    }
    $rtrP->cli('en');
    $rtrP->cli('configure');
    $rtrP->cli('redundancy group');
    $lastRes = $rtrP->cli('tree');
    my $psk = 0;
    if (index($lastRes, "password") == -1) {
        $psk = `dd if=/dev/urandom bs=1 count=32 2> /dev/null| base64 -w 0`;
    }
    $rtrP->cli('end');
    $rtrP->cli('exit');

    if ($rtrM) {
	$lastRes = $rtrM->cli('show redundancy');
	my ($operatingMode) = ($lastRes =~ /Operating Mode\s*: ([\w\s]+?)\s*$/ms);
	if ($operatingMode cmp "Monitoring Node") {
	    print "$rtrMname should be in monitor node mode.\n";
	    print "  __\n";
	    print " /  \\         _______________________________________________\n";
	    print " |  |       /                                               \\\n";
	    print " @  @       | It looks like you are trying to use a          |\n";
	    print " || ||      | messaging node as a monitoring node.           |\n";
	    print " || ||  <---| Type \'reload default-config monitoring-node\'   |\n";
	    print " |\\_/|      | to switch modes.                               |\n";
	    print " \\___/      \\_______________________________________________/\n";
	    print "\n";
	    print "\n";
	    exit 1;
	}
    }

    print "====================GATHERED DATA====================\n";
    if ($isConsul) {
        print "  Distributed DB:      Consul\n";
    } else {
        print "  Distributed DB:      Pacemaker\n";
    }
    if ($psk) {
        print "  Redundancy PSK:      $psk\n"
    } else {
        print "  Group password:      'qwerty'\n"
    }
    print "  Primary\n";
    print "    $rtrPname\n";
    print "    Static/Mgmt IP: $rtrPip\n";
    print "  Backup\n";
    print "    $rtrBname\n";
    print "    Static/Mgmt IP: $rtrBip\n";
    print "  Monitor\n";
    print "    $rtrMname\n";
    print "    Management: $rtrMip\n";
    print "\n";
    print "=====================================================\n";
    if ($args{prompt}) {
	print "\nPress enter to accept. (C-c to quit)\n";
	<STDIN>;
    }

    #    PRIMARY
    $rtrP->cli("enable");
    $rtrP->cli("configure");
    $rtrP->cli("hardware message-spool shutdown");

    #     BACKUP
    $rtrB->cli("enable");
    $rtrB->cli("configure");
    $rtrB->cli("hardware message-spool shutdown");

    #     MONITOR
    if ($rtrM) {
	$rtrM->cli("enable");
	$rtrM->cli("configure");
    }

    my @routers = ($rtrP, $rtrB, $rtrM);
    foreach my $rtr (@routers) {
	if (!$rtr) {
	    next;
	}
        $rtr->cli("no service redundancy shutdown");  # just to be safe
        $rtr->cli("redundancy");
        $rtr->cli("  group");
        $rtr->cli("    create node $rtrPname");
        if ($isConsul) {
            $rtr->cli("      connect-via $rtrPip");
        } else {
            $rtr->cli("      ip $rtrPip");
        }
        $rtr->cli("      node-type message-routing-node");
        $rtr->cli("      exit");
        $rtr->cli("    create node $rtrBname");
        if ($isConsul) {
            $rtr->cli("      connect-via $rtrBip");
        } else {
            $rtr->cli("      ip $rtrBip");
        }
        $rtr->cli("      node-type message-routing-node");
        $rtr->cli("      exit");
        $rtr->cli("    create node $rtrMname");
        if ($isConsul) {
            $rtr->cli("      connect-via $rtrMip");
        } else {
            $rtr->cli("      ip $rtrMip");
        }
        $rtr->cli("      node-type monitor-node");
        $rtr->cli("      exit");
        $rtr->cli("    exit");
        if ($psk) {
            $rtr->cli("  authentication pre-shared-key key $psk");
        } else {
            $rtr->cli("  group password qwerty");
        }
    }
    $rtrP->cli("  active-standby-role primary");
    $rtrB->cli("  active-standby-role backup");
    if (!$psk) {
        # VMRs that have PSKs have also deprecated the mate-link connect-via command
        $rtrP->cli("  mate-link connect-via $rtrBip");
        $rtrB->cli("  mate-link connect-via $rtrPip");
    }
    if ($args{tls}) {
        $rtrP->cli("  mate-link ssl");
        $rtrB->cli("  mate-link ssl");
    }
    foreach my $rtr (@routers) {
	if (!$rtr) {
	    next;
	}
        $rtr->cli("  no shutdown");
        $rtr->cli("  exit");
    }

    if ($args{message_spool}) {
        $rtrP->cli("no service mate-link shutdown");
        $rtrB->cli("no service mate-link shutdown");        
        $rtrP->cli("no hardware message-spool shutdown");
        $rtrB->cli("no hardware message-spool shutdown");
    }

    if ($args{message_spool} && $args{config_sync}) {
        for my $rtr ($rtrP, $rtrB) {
            $rtr->cli("end");
            $rtr->cli("configure");
            $rtr->cli("no config-sync shutdown");
            $rtr->cli("end");
        }
        $rtrP->cli("admin");
        $rtrP->cli("config-sync");
        $rtrP->cli("assert-master router");
    }

} # Main

##############################################################################
## connectToRouter - 
##
##############################################################################
sub connectToRouter {
  my $attempts = 3;

  my $timeout = $attempts;
  while ($timeout--) {
    waitForPing($_[0]);
    Debug("Trying to connect to router $_[0]");
    my $rtr = Solace::Simple->new(router => $_[0],
                                  dieOnError => 0,
                                  debug => $args{debug},
                                  verbose => $args{debug} || $args{verbose});
    if ($rtr) {
      if ($rtr->connect("cli")) {
        Debug("Connect to CLI succeeded");
        return $rtr;
      }
    }
    
  }

  Fatal("Failed to connect to router $_[0] after $attempts attempts");

} # connectToRouter #


##############################################################################
## waitForPing - 
##
##############################################################################
sub waitForPing {
  
  my $attempts = 3;
  my $timeout = $attempts;
  while ($timeout--) {
    Debug("Pinging router $_[0]");
    my $out = `ping -c 1 -w 1 $_[0]`;
    if ($out =~ /1 received/) {
      Debug("Ping succeeded");
      return;
    }
  }

  Error("Failed to ping router after $attempts attempts.");

} # waitForPing #


##--User Code End--##


##############################################################################
## ParseArgs - Parse the command line arguments
##
##############################################################################
sub ParseArgs {
  
  # Options Parsing
  @allArgs = @ARGV;

  my %defaultArgs = %args;
  %args = ();

  # Converts position arguments to names
  my @posToName = (
  );

  # Converts position arguments to names
  my @posToType = (
  );

  # All required arguments
  my %requiredArgs = (
           'primary' => 1,
           'backup' => 1,
  );

  # All hides-required arguments
  my %hidesRequiredArgs = (
  );

  # All enum arguments
  my %enumArgs = (
  );

  # Cross ref of perl version of args to command line version
  my %perlToCmdArg = (
                       'primary' => 'primary',
                       'backup' => 'backup',
                       'monitor' => 'monitor',
                       'tls' => 'tls',
                       'message_spool' => 'message-spool',
                       'config_sync' => 'config-sync',
                       'prompt' => 'prompt',
                       'debug' => 'debug',
                       'gen_completion' => 'gen-completion',
                       'help' => 'help',
                       'interactive' => 'interactive',
                       'quiet' => 'quiet',
                       'short_help' => 'short-help',
                       'tiny_help' => 'tiny-help',
                       'verbose' => 'verbose',
  );


  LearnArgsFromConfFile();

  my $result = GetOptions (
                           'primary=s' => \$args{primary},
                           'backup=s' => \$args{backup},
                           'monitor=s' => \$args{monitor},
                           'tls' => \$args{tls},
                           'message-spool' => \$args{message_spool},
                           'config-sync' => \$args{config_sync},
                           'prompt!' => \$args{prompt},
                           'debug' => \$args{debug},
                           'gen-completion' => \$args{gen_completion},
                           'help' => \$args{help},
                           'interactive' => \$args{interactive},
                           'quiet' => \$args{quiet},
                           'short-help' => \$args{short_help},
                           'tiny-help' => \$args{tiny_help},
                           'verbose' => \$args{verbose},
  );

  if (!$result) { exit 1; }

  # Positional argument processing

  my $posIdx = 0;
  while (@ARGV) {
    last if $posIdx >= 0;
  
    $args{$posToName[$posIdx]} = shift @ARGV;
    if ($posToType[$posIdx] eq 'integer') {
      $args{$posToName[$posIdx]} = 
         StrToNum($args{$posToName[$posIdx]}, "Invalid argument, failed to convert $args{$posToName[$posIdx]} to number");
    }
    delete $requiredArgs{$posToName[$posIdx]};
    $posIdx++;
  }

  @remainingArgs = @ARGV;
  @parsedArgs = @allArgs[0..(scalar(@allArgs)-scalar(@remainingArgs)-1)];

  Fatal("${BOLDr}Unrecognized argument(s):$NORMAL " . join(' ', @ARGV)) if $#ARGV > -1;

  foreach my $arg (keys(%args)) {
    $parsedArgs{$arg} = 1 if defined $args{$arg};
  }

  foreach my $arg (keys(%defaultArgs)) {
    $args{$arg} = $defaultArgs{$arg} if !defined $args{$arg};
  }

  # Standard option processing

  if ($args{gen_completion}) {
    print "--primary --backup --monitor --tls --message-spool --config-sync --prompt --debug --help --interactive --quiet --short-help --tiny-help --verbose ";
    exit 1;
  }

  if ($args{help}) {
    
    pod2usage(-verbose => 2);    
    exit 1;
  }
  if ($args{short_help}) {
    
    pod2usage(-verbose => 1);
    exit 1;
  }
  if ($args{tiny_help}) {
    my $info = GetArgInfo();
    print "$info->{Name} - $info->{ShortDescription}\n";
    exit 1;
  }

  my $showCmdLine = 0;
  if ($args{interactive}) {
    PromptForArgs(1, %args);
    $showCmdLine = 1;
  }

  my $hidesRequired = 0;
  foreach my $key (keys(%hidesRequiredArgs)) {
    if (defined $args{$key}) {
      $hidesRequired = 1;
      last;
    }
  }
  
  # Check for missing required params
  if (!$hidesRequired) {
    foreach my $key (keys(%requiredArgs)) {
      if (defined $args{$key}) {
        delete $requiredArgs{$key};
      }
    }
    if (scalar(keys(%requiredArgs)) > 0) {
      print "\nMissing some required parameters\n";
      PromptForArgs(1, %requiredArgs);
      $showCmdLine = 1;
    }
  }
  
  # Check that enums have valid values
  my $argInfo = GetArgInfo();
  foreach my $arg (keys(%enumArgs)) {
    if (defined $args{$arg}) {
      my $argList = ref($args{$arg}) ? $args{$arg} : [$args{$arg}];
      foreach my $val (@{$argList}) {
        if (not defined $enumArgs{$arg}{$val}) {
          print "\nInvalid value '$val' for argument $arg.  Valid values are:\n";
          foreach my $value (keys(%{$enumArgs{$arg}})) {
            print "  $value\n";
          }
          exit 1;
        }
      }
    }
  }
  
  if ($showCmdLine) {
    # Output the command line for this
    DisplayCommandLine();
  }

} # ParseArgs #

##############################################################################
## PromptForArgs - Will ask the user for values for various arguments
##
## skipAutoArgs: When true, it will not prompt for --interactive, --debug,
##               --quiet, --verbose or --help
##
##############################################################################
sub PromptForArgs {
  my ($skipAutoArgs, %argsForPrompting) = @_;
  my $argInfo = GetArgInfo();
  
  print "\nInteractive Input:\n\n";
  foreach my $arg (@{$argInfo->{Args}}) {
    my $name = $arg->{Name};
    my $perlName = $arg->{PerlName};
    if (not exists $argsForPrompting{$perlName}) {
      next;
    }
    if ($skipAutoArgs && 
        ($name =~ /^(debug|interactive|quiet|verbose|help|gen-completion)$/)) {
      next;
    }
    my $desc = $arg->{Description};
    my $space = " " x (length($name) + 3);
    $desc =~ s/(.{1,75 - length($name)})(?:\s|$|\n)/$1\n$space/g;
    my $prompt = "\n$BOLD$name$NORMAL - $arg->{Description}";
    my $default = '';
    my $defVal = '';
    if (defined $args{$perlName}) {
      $default = " [$args{$perlName}]";
      $defVal = $args{$perlName};
    }
    elsif ($arg->{Default}) {
      $default = " [$arg->{Default}]";
      $defVal = $arg->{Default};
    }
    while (1) {
      if ($arg->{ValType} eq 'boolean') {
        print $prompt . "\nEnter value for flag (undef, 0 or 1)$default: ";
      }
      elsif ($arg->{ValType} =~ /integer|float/) {
        print $prompt . "\nEnter numeric value$default: ";
      }
      elsif ($arg->{ValType} eq 'enum') {
        print $prompt . "\nSelect value: ";
      }
      else {
        print $prompt . "\nEnter value$default: ";
      }
      my $response;
      if ($arg->{ValType} eq 'enum') {
        print "\n";
        $default = '';
        my $num = 1;
        my $defaultNum;
        foreach my $val (@{$arg->{EnumList}}) {
          print "  $num: $val\n";
          if ($val eq $defVal) {
            $default = "[$num]";
            $defaultNum = $num;
          }
          $num++;
        }
        while (1) {
          print "Select number$default: "; 
          chomp($response = <STDIN>);
          if ($response eq '') {
            $response = defined $defaultNum ? $defaultNum : 0;
          }
          if ($response >= 1 &&
              $response <= scalar(@{$arg->{EnumList}})) {
            $response = $arg->{EnumList}[$response-1];
            last;
          }
          print "Invalid selection - try again\n";
        }
      }
      else {
        chomp($response = <STDIN>);
      }
      if ($arg->{Required} && 
          (not defined $args{$perlName}) &&
          $response eq '') {
        print "You must enter a value for this argument\n";
      }
      else {
        if ($response eq '' && 
            defined $args{$perlName}) {
          # Keep the same value
        }
        elsif ($response eq '' && 
               defined $arg->{Default}) {
          $args{$perlName} = $arg->{Default};
        }
        else {
          if ($arg->{ValType} eq 'integer') {
            $args{$perlName} =
              StrToNum($response, "Failed to convert $response to number");
          }
          else {
            $args{$perlName} = $response;
          }
        }
        if (($arg->{ValType} eq 'boolean') && 
            (($args{$perlName} eq 'undef') || ($args{$perlName}) eq ''))  {
          $args{$perlName} = undef;
        }
        last;
      }
    }
  }

}



##############################################################################
## LearnArgsFromConfFile - This will open the appropriate .conf file to get
##                       additional arguments
##
##############################################################################
sub LearnArgsFromConfFile {
  my $homeDir;
  if (exists $ENV{'HOME'}) {
    $homeDir = $ENV{'HOME'};
  } else {
    # Some flavour of Windows? Try this:
    $homeDir = $ENV{'USERPROFILE'};
  }
  return if !$homeDir;
  return if !(-e "$homeDir");
  return if !(-e "$homeDir/.scripts");

  my $conf = "$homeDir/.scripts/rs-vm-config-group.conf";
  return if !(-e $conf);

  # The file exists - suck it in and parse out the goodness
  open(IN, $conf) || return;
  my @data = <IN>;
  close(IN);

  my $section = "";
  my $quiet = 0;
  foreach my $line (@data) {
    if ($line =~ /^\s*\[([^\]]+)\]/) {
      $section = $1;
    }
    elsif ($section =~ /^(args)|(command-line-args)|(cmd-line-args)|(cmdline-args)/i || $section eq "") {
      if ($line =~ /^\s*([\w\-\_\d]+)\s*=\s*([^\n\s\#\;]+)/) {
        my $arg = $1;
        my $val = $2;
        print "Defaulting argument --$1 to $2 from .conf file\n" unless $quiet;
        # Put the arg at the head of the arg list
        unshift(@ARGV, "--$arg=$val");
      }
      elsif ($line =~ /^\s*([\w\-\_\d]+)\s*$/) {
        my $arg = $1;
        print "Defaulting flag --$1 to on from .conf file\n" unless $quiet;
        # Put the arg at the head of the arg list
        unshift(@ARGV, "--$arg");
      }
    }
    elsif ($section =~ /^global-?settings/i) {
      if ($line =~ /^\s*([\w\-\_\d]+)\s*=\s*([^\n\s\#\;]+)/) {
        my $arg = $1;
        my $val = $2;
        if (lc($arg) eq "quiet") {
          $quiet = $val;
          unshift(@ARGV, "--quiet") if $val;
        }
      }
    }
  }
  
} # LearnArgsFromConfFile


##############################################################################
## GetArgInfo - This will return all the script information in perl
##              struct form.
##
##############################################################################
sub GetArgInfo {

  my $cfgInfo = {
             'Lang' => 'perl',
             'SuperScriptRevision' => '7505',
             'ShortDescription' => ' ',
             'ParsingType' => 'unordered',
             'Description' => '
',
             'Name' => 'rs-vm-config-group',
             'Args' => [
                         {
                           'Type' => 'named',
                           'Required' => 1,
                           'ValType' => 'string',
                           'Description' => 'the hostname or ip of the primary router',
                           'Name' => 'primary',
                           'PerlName' => 'primary'
                         },
                         {
                           'Type' => 'named',
                           'Required' => 1,
                           'ValType' => 'string',
                           'Description' => 'the hostname or ip of the backup router',
                           'Name' => 'backup',
                           'PerlName' => 'backup'
                         },
                         {
                           'Type' => 'named',
                           'Default' => '',
                           'Required' => 0,
                           'ValType' => 'string',
                           'Name' => 'monitor',
                           'Description' => 'the hostname or ip of the monitor node',
                           'PerlName' => 'monitor'
                         },
                         {
                           'Default' => 0,
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Name' => 'tls',
                           'Description' => 'enable mate link tls',
                           'PerlName' => 'tls'
                         },
                         {
                           'Default' => 0,
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Name' => 'message-spool',
                           'Description' => 'no shut mate-link/message-spool',
                           'PerlName' => 'message_spool'
                         },
                         {
                           'Default' => 0,
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Description' => 'no shut config-sync',
                           'Name' => 'config-sync',
                           'PerlName' => 'config_sync'
                         },
                         {
                           'Default' => 1,
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'AllowNo' => 1,
                           'Type' => 'named',
                           'Name' => 'prompt',
                           'Description' => 'prompt to continue after gathering data',
                           'PerlName' => 'prompt'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Turn on all debug output.',
                           'Name' => 'debug',
                           'PerlName' => 'debug'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Prints out completion info for the parameters',
                           'Name' => 'gen-completion',
                           'PerlName' => 'gen_completion'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out usage info for this script',
                           'Name' => 'help',
                           'PerlName' => 'help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Query the user for values for each of the arguments, providing help for each.  This will print out the appropriate command line for future reference before executing the script.',
                           'Name' => 'interactive',
                           'PerlName' => 'interactive'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Reduce the amount of output to the bare minimum.',
                           'Name' => 'quiet',
                           'PerlName' => 'quiet'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out usage summary for this script',
                           'Name' => 'short-help',
                           'PerlName' => 'short_help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out one line description for this script',
                           'Name' => 'tiny-help',
                           'PerlName' => 'tiny_help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out more user-level output',
                           'Name' => 'verbose',
                           'PerlName' => 'verbose'
                         }
                       ],
             'PositionalListIdx' => undef
           };

  return $cfgInfo;

} # GetArgInfo


##############################################################################
## DisplayCommandLine - This will print out the command line for the
##                      current arguments
##
##############################################################################
sub DisplayCommandLine {

  my $argInfo = GetArgInfo();

  # my $output = "$argInfo->{Name} ";
  my $output = "$0 ";
  my $positional = '';

  foreach my $arg (@{$argInfo->{Args}}) {
    my $name = $arg->{Name};
    my $perlName = $arg->{PerlName};
    if (not defined $args{$perlName}) {
      next;
    }
    if (defined $arg->{Default} && 
        $args{$perlName} eq $arg->{Default}) {
      next;
    }
    if ($perlName eq 'interactive') {
      next;
    }

    my $value = $args{$perlName};
    if ($value =~ /\s/) {
      $value = "'$value'";
    }
    
    if ($arg->{Type} eq 'named') {
      if ($arg->{ValType} eq 'boolean') {
        if (defined $args{$perlName}) {
          if ($args{$perlName} == 0) {
            $output .= "--no-$name ";
          }
          else {
            $output .= "--$name ";
          }
        }
      }
      else {
        $output .= "--$name=$value ";
      }
    }
    else {
      if (ref $value eq 'ARRAY') {
        if (scalar(@{$value} > 1) || $value->[0] ne '') {
          $positional .= "@{$value} ";
        }
      }
      else {
        $positional .= "$value ";
      }
    }

  }
  
  print "Command line:\n";
  print "$output$positional\n\n";
  # `history -s $output$positional`;

} # DisplayCommandLine #


##############################################################################
## Log - Handle output messaging
##
##############################################################################
sub Log {
  my ($level, $message, $addCaller, $opts) = @_;

  return 0 if $level eq 'DEBUG' && !$args{debug};
  return 0 if $level eq 'INFO'  && ($args{quiet} || (!$args{debug} && !$args{verbose}));
  return 0 if $level eq 'WARN'  && $args{quiet};

  print("$level: ") if $level ne 'MSG' || $addCaller;
  if ($addCaller) {
    my @caller = caller(1);
    $caller[1] =~  s/^.*\///;
    print("$caller[1]:$caller[2]: ");
  }
  print("$message\n");

  exit 1 if $level eq 'FATAL';

} # Log #

 
sub Fatal { Log('FATAL', @_) };
sub Error { Log('ERROR', @_) };
sub Warn  { Log('WARN',  @_) };
sub Info  { Log('INFO',  @_) };
sub Debug { Log('DEBUG', @_) };
sub Msg   { Log('MSG',   @_) };



##############################################################################
## StrToNum - Convert strings into numbers
##
##############################################################################
sub StrToNum {
  my ($string, $failMsg) = @_;

  Fatal($failMsg) if $string !~ 
      /^([-+]?_*[1-9][0-9_]*  |
         0x_*[0-9a-f][0-9a-f_]* |
         0b_*[01][01_]*         |
         0[0-7_]*)$
      /xi;

  ($string) = ($string =~ /(.*)/);
  my $num = eval($string);
  
  Fatal($@) if $@;
  return $num;

} # StrToNum #


 

__END__

=head1 NAME

rs-vm-config-group

=head1 DESCRIPTION




=head1 OPTIONS

rs-vm-config-group [OPTIONS] 

Where:

=over

=item --primary=<string> B<*Required*>

the hostname or ip of the primary router

=item --backup=<string> B<*Required*>

the hostname or ip of the backup router

=item --monitor=<string>

the hostname or ip of the monitor node

=item --tls

enable mate link tls

=item --message-spool

no shut mate-link/message-spool

=item --config-sync

no shut config-sync

=item --prompt or --no-prompt

prompt to continue after gathering data
[Default: 1]

=item --interactive

Query the user for values for each of the arguments, providing help for each.  This will print out the appropriate command line for future reference before executing the script.

=item --help, --short-help, --tiny-help

Display various levels of usage information

=item --quiet, --verbose, --debug

Control the amount of information printed during execution

=back

