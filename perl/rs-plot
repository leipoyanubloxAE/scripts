#!/usr/bin/perl
#
# Script: rs-plot
#
# Poll a router for various stats and plot them on a graph.  It will also keep
# a timestamped file of the stats collected.  The list of stats that can be
# polled is stored in devtools/bin/rs-plot-rules.  You can load custom rules by
# putting them in your custom rule file in ~/.rs-plot-rules.  See
# devtools/bin/rs-plot-rules for the format.
# 
#
# The framework of the script was autogenerated by version 3622 of
# /usr/local/devtools/bin/super-script.
#
#############################################################################


use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;
use Pod::Usage;

use constant BOLD    => "\e[1m";
use constant NORMAL  => "\e[0m";

my $BOLD   = BOLD;
my $NORMAL = NORMAL;
my $BOLDr  = "[31m[1m";  # Red
my $BOLDg  = "[32m[1m";  # Green

# Main hash - all the argument values will be in here after parsing
my %args = (
            interval => '1',
            router => undef,
            outfile => '/tmp/rs-plot.txt',
            plot_interval => '5',
            cfg_file => '~/.rs-plot',
            stats_or_groups => [''],
            list => '0',
            cb => '0',
            debug => undef,
            gen_completion => undef,
            help => undef,
            interactive => undef,
            quiet => undef,
            short_help => undef,
            tiny_help => undef,
            verbose => undef,
);

# Arrays to hold the parsed and unparsed args
my @remainingArgs;
my @allArgs;
my @parsedArgs;
my %parsedArgs;

# Keep track of whether or not we have printed a '.' while waiting for the router
my $printedDot_g = 0;

ParseArgs();

##--User Code Start--##

use FindBin;
use lib "$FindBin::Bin/../../../lib/perl";
use lib "$FindBin::Bin/../lib/perl";
use Solace::Expect;
use Time::HiRes qw( gettimeofday );
use Term::ReadKey;

# Global cli, soldebug and linux handlers
my %handles_g;

# Holds all the stat rules
my %rules_g;

# Holds the stats to collect
my %selectedStats_g;
my @stats_g;
my %collectRules_g;

# Holds the list of saved configs
my %savedConfigs_g;

# Output file handle
my $outfile_g;

# Call main - the start of the script
Main();

##############################################################################
## Main - Starting point for the script
##
##############################################################################
sub Main {

  print "\nrs-plot - a way to plot any cli, linux or soldebug stats\n";
  print "\nNOTE - for any dialogs, if BACKSPACE doesn't work, try CTRL-BACKSPACE\n\n";
  
  LoadRules();

  my $plot         = StartGnuplot();
  my $start        = gettimeofday();
  my $lastPlotTime = 0;
  my $decayFactor  = 60;

  $args{outfile} .= ".$$";

  OpenOutfile();

  PrintPrompt();

  my @statLastVals;
  my @statLastAvg;
  my $lastTime = 0;
  while(1) {

    my @statVals = CollectStats();
    my $t  = gettimeofday();
    my $dt = $t - $lastTime;

    for my $i (0 .. scalar(@statVals) - 1) {

      $statVals[$i] ||= 0;

      if (!defined($statLastVals[$i])) {
        $statLastVals[$i] = $statVals[$i];
      }

      my $rate;
      if ($stats_g[$i][5] =~ /rate/i) {
        $rate = ($statVals[$i] - $statLastVals[$i]) / $dt;
        $statLastVals[$i] = $statVals[$i];
        $statVals[$i] = $rate;
      }

      if ($stats_g[$i][5] =~ /avgrate/i) {
        $statLastAvg[$i] = $rate if !defined($statLastAvg[$i]);
        my $avgRate = $rate/$decayFactor + $statLastAvg[$i]*($decayFactor-1)/$decayFactor;
        $statLastAvg[$i]   = $avgRate;
        $statVals[$i]      = $avgRate;
      }

      if ($stats_g[$i][5] =~ /^avg$/i) {
        $statLastAvg[$i] = $statVals[$i] if !defined($statLastAvg[$i]);
        my $avg = $statVals[$i]/$decayFactor + $statLastAvg[$i]*($decayFactor-1)/$decayFactor;
        $statLastVals[$i] = $statVals[$i];
        $statLastAvg[$i]  = $avg;
        $statVals[$i]     = $avg;
      }

    }

    WriteStatsToDisk($t, \@statVals);

    if ($t - $lastPlotTime > $args{plot_interval}) {
      RegenPlot($plot);
      $lastPlotTime = $t;
    }
    
    $lastTime = $t;

    # Will get and process keystrokes and wait the interval time
    my $rc = GetInputAndWait();

    if (defined($rc) && $rc eq 'reset') {
      @statLastVals = ();
      @statLastAvg  = ();
    }

  }

}


##############################################################################
## GetInputAndWait - 
##
## This will wait the polling interval and process any keystrokes that are
## typed while waiting 
##
##############################################################################
sub GetInputAndWait {
  # my () = @_;

  ReadMode 4;
  my $char = ReadKey($args{interval});
  ReadMode 0;

  return if !defined $char;

  my $printPrompt = 1;
  if ($char =~ /a/i) {
    AddStatMenu();
  }
  elsif ($char =~ /r/i) {
    RemoveStat();
  }
  # elsif ($char =~ /e/i) {
  #   EditStat();
  # }
  elsif ($char =~ /s/i) {
    SaveConfig();
  }
  elsif ($char =~ /l/i) {
    LoadConfig();
    return "reset";
  }
  elsif ($char =~ /[q]/i) {
    print "quiting...\n";
    exit;
  }
  elsif ($char =~ /C/) {
    ClearPlot();
  }
  elsif ($char =~ /n/) {
    LearnStat();
  }
  elsif ($char =~ /\?/) {
    PrintHelp();
  }
  else {
    $printPrompt = 0;
  }

  PrintPrompt() if $printPrompt;

} # GetInputAndWait #


##############################################################################
## PrintHelp - 
##
##############################################################################
sub PrintHelp {

  print "
RS-PLOT

rs-plot will poll statistics from the router and plot them using gnuplot.
While running, the pressing following keys will perform the described
action:

a - Add new stat
r - Remove a stat
s - Save current configuration of stats 
l - Load one of the save stat configurations
C - Clear the current stats from the plot
n - Learn new rule - this is an interactive way to add stats
q - Quit

Saved configurationws will appear in ~/.rs-plot.  That file can also
be augmented with additional stat retrieval rules in order to add
custom stats to rs-plot.  These additional rules must appear under the
[Rules] section of the config file.  Look at the instructions in
devtools/bin/rs-plot-rules for the format of these rules.  
NOTE - if it is a generally useful statistic, please add it to
devtools/bin/rs-plot-rules so that everyone can benefit.

";


} # PrintHelp #



##############################################################################
## SaveConfig - This will save the set of stats 
##
##############################################################################
sub SaveConfig {
  # my () = @_;

  while (1) {
    print "\n${BOLD}Enter name for this group of stats: ${NORMAL}";
    chomp(my $name = <STDIN>);
    $name =~ s/^\s*//;
    $name =~ s/\s*$//;
    
    if (exists($savedConfigs_g{$name})) {
      if (!YOrN("There is already a stat group saved with that name.  Overwrite it?")) {
        next;
      }
      delete($savedConfigs_g{$name});
    }
    
    my $s = \%selectedStats_g;
    foreach my $stat (sort {$s->{$a}{index} <=> $s->{$b}{index}} (keys(%{$s}))) {
      next if ($s->{$stat}{disable});
      push(@{$savedConfigs_g{$name}}, "$stat:{axis:$s->{$stat}{axis}}");
    }

    last;
  }

  #print Dumper \%selectedStats_g;
  #print Dumper \%savedConfigs_g;

  RewriteSavedStatGroups();

} # SaveConfig #


##############################################################################
## LoadConfig - Load one of the configured stat groups 
##
##############################################################################
sub LoadConfig {
  # my () = @_;

  my %menu = (title => "Configure stat groups",
              prompt => "Choose group"
      );
  
  foreach my $group (sort(keys(%savedConfigs_g))) {
    push(@{$menu{items}}, $group);
  }

  my $group = DoMenu(\%menu);

  if (@stats_g && YOrN("Remove existing stats before adding these?")) {
    RemoveAllStats();
  }

  foreach my $stat (@{$savedConfigs_g{$group}}) {
    my ($name, $params) = ($stat =~ /([\w\d\-\_\.]+):{([^}]*)}/);
    my %params = split(/,|:/, $params);
    AddStat($name, \%params);
  }


} # LoadConfig #


##############################################################################
## ClearPlot - Clear the plot 
##
##############################################################################
sub ClearPlot {
  # my () = @_;

  ClearStats();

} # ClearPlot #



##############################################################################
## RemoveAllStats - 
##
## Clear out the stats file and reinit all the stat structures 
##
##############################################################################
sub RemoveAllStats {
  # my () = @_;

  ClearStats();

  %selectedStats_g  = ();
  @stats_g = ();
  %collectRules_g = ();

} # RemoveAllStats #



##############################################################################
## RewriteSavedStatGroups - 
##
## Open the config file and substitute the existing saved groups for the
## current ones 
##
##############################################################################
sub RewriteSavedStatGroups {
  # my () = @_;

  my $section = "[StatGroups]\n\n";

  foreach my $group (keys(%savedConfigs_g)) {
    $section .= "$group = " . join(", ", @{$savedConfigs_g{$group}});
    $section .= "\n";
  }


  if (! -e $args{cfg_file}) {
    open(CFG, ">", $args{cfg_file}) || (Error("Failed to write to config file ($args{cfg_file}): $!") && return);
    print CFG $section;
    close(CFG);
    return;
  }

  open(CFG, "<", $args{cfg_file}) || (Error("Failed to open the config file ($args{cfg_file}): $!") && return);
  my $cfg;
  while (my $l = <CFG>) {
    $cfg .= $l;
  }
  close(CFG);

  if ($cfg !~ /\[statgroups\]/) {
    $cfg .= "\n$section\n";
  }
  else {
    $cfg =~ s/(^|\n)\s*\[statgroups\](?:.|\n)*?((?:\s*\[[\w\s]+\])|\s*$)/$1$section$2/i;
  }

  open(CFG, ">", $args{cfg_file}) || (Error("Failed to write to config file ($args{cfg_file}): $!") && return);
  print CFG $cfg;
  close(CFG);

} # RewriteSavedStatGroups #


##############################################################################
## SaveRuleToConfigFile - 
##
## This will add the specified rule to the user's config file 
##
##############################################################################
sub SaveRuleToConfigFile {
  my ($rule) = @_;

  map {
    if ($_ =~ /'/) {
      $_ = "\"$_\"";
    }
    elsif ($_ =~ /"/) {
      $_ = "'$_'";
    }
  } @{$rule};
  
  my $ruleStr = join(", ", @{$rule});

  if (! -e $args{cfg_file}) {
    open(CFG, ">", $args{cfg_file}) || (Error("Failed to write to config file ($args{cfg_file}): $!") && return);
    print CFG "[Rules]\n\n";
    print CFG "$ruleStr\n";
    close(CFG);
    return;
  }

  open(CFG, "<", $args{cfg_file}) || (Error("Failed to open the config file ($args{cfg_file}): $!") && return);
  my $cfg;
  while (my $l = <CFG>) {
    $cfg .= $l;
  }
  close(CFG);

  $cfg =~ s/([Rules].*\n)/$1$ruleStr\n/i;
  open(CFG, ">", $args{cfg_file}) || (Error("Failed to write to config file ($args{cfg_file}): $!") && return);
  print CFG $cfg;
  close(CFG);
  
} # SaveRuleToConfigFile #



##############################################################################
## RemoveStat - 
##
##############################################################################
sub RemoveStat {
  # my () = @_;

  my %menu = (title => "Active stats",
              prompt => "Choose stat to remove"
      );

  my $s = \%selectedStats_g;

  my @stats;
  foreach my $name (sort {$s->{$a}{index} <=> $s->{$b}{index}} (keys(%{$s}))) {
    next if $s->{$name}{disable};
    push(@{$menu{items}}, $name);
  }

  push(@{$menu{items}}, "Don't remove any stat");

  my $stat = DoMenu(\%menu);

  if ($stat eq "Don't remove any stat") {
    return;
  }

  $s->{$stat}{disable} = 1;


} # RemoveStat #


##############################################################################
## AddStatMenu - 
##
##############################################################################
sub AddStatMenu {
  # my () = @_;

  my %menu = (title => "Stat Group",
              prompt => "Choose group"
      );

  my %statNames;
  foreach my $group (sort(keys(%{$rules_g{groups}}))) {
    my %subMenu = (title => "Stats in group $group",
                   prompt => "Choose stat");
    foreach my $stat (@{$rules_g{groups}{$group}}) {
      $statNames{$stat->[2]} = $stat;
      push(@{$subMenu{items}}, {name => "$stat->[1] ($stat->[2])",
                                value => $stat->[2]});
    }
    push(@{$menu{items}}, {name => $group,
                           menu => \%subMenu});
  }

  push(@{$menu{items}}, {name => "Learn new stat rule",
                         value => "learn"});

  my $stat = DoMenu(\%menu);

  if ($stat eq "learn") {
    LearnStat();
    return;
  }

  my $axis = DoMenu({title => "Which y-axis",
                     prompt => "Select axis",
                     items => ["primary",
                               "secondary"]});

  AddStat($stat, {axis => $axis});

  # Remove the current file - this should be made nicer in the future
  ClearStats();

} # AddStatMenu #


##############################################################################
## AddStat - This will add a single statistic 
##
##############################################################################
sub AddStat {
  my ($name, $params) = @_;

  if ($selectedStats_g{$name}) {
    # we already have this stat - just change its axis and enable it
    $selectedStats_g{$name}{axis} = $params->{axis} if defined($params->{axis});
    delete($selectedStats_g{$name}{disable});
    return;
  }

  my $info = $rules_g{stats}{$name};
  my $idx  = scalar(@stats_g);
  $selectedStats_g{$name} = {axis  => (defined($params->{axis}) ? $params->{axis} : "primary"),
                             index => $idx,
                             info  => $info,
  };
  $stats_g[$idx] = $info;

  $collectRules_g{$info->[3]}{$info->[4]}++;

} # AddStat #


##############################################################################
## LearnStat - 
##
## This will provide an interactive interface for adding new stat rules 
##
##############################################################################
sub LearnStat {
  # my () = @_;

  print "\nLearning a new stat rule.  \n";

  my $cmdType = DoMenu({title => "Command type choices",
                        prompt => "Select type",
                        items => ["cli", "soldebug", "linux"]});
  
  if ($cmdType eq "soldebug") {
    while (1) {
      print "Enter the 'conn' string for soldebug (e.g. ':conn 3'): ";
      chomp(my $connStr = <STDIN>);
      $connStr =~ s/^\s*://;
      if ($connStr !~ /^l?conn\s+\d+/) {
        if (YOrN("Invalid connection string.  Try again?")) {
          next;
        }
        else {
          return;
        }
      }
      $cmdType .= ":$connStr";
      last;
    }
  }

  my $cmd;
  while (1) {
    print "Enter the command string (e.g. 'show stats client'): ";
    chomp($cmd = <STDIN>);
    if ($cmd =~ /^\s*$/) {
      print "Quitting learning stat...\n";
    }
    
    my $h = GetHandle($cmdType);
    if (!defined($h)) {
      print "Failed to get a connection handle for $cmdType\n";
      return;
    }
    
    my $result = $h->send($cmd);
    
    print "$result\n";
    if (!YOrN("Is this the command output you expected?")) {
      if (YOrN("Enter a new command?")) {
        next;
      }
      else {
        last;
      }
    }
    
    my $regexp = FindRegexpForStat($result);

    if (!defined($regexp)) {
      print "No regexp found for stat.\n";
      return;
    }

    my $statType = DoMenu({title => "Post processing options:",
                        prompt => "Select type",
                        items => [{name => "Plot the stat 'as is'", value => 'AsIs'},
                                  {name => "Plot a decaying average of the stat", value => 'Avg'},
                                  {name => "Convert the stat into a rate", value => 'Rate'},
                                  {name => "Convert to a decaying average of the rate", value => 'AvgRate'},
                            ]});

    print "Enter a name for the stat (e.g. client-ingress-msg-rate): ";
    my $statName = <STDIN>;
    $statName =~ s/^\s+//;
    $statName =~ s/\n.*//sm;
    $statName =~ s/\s+/-/g;

    my $rule = ["Newly Learned", $statName, $statName, $cmdType, $cmd, $statType, $regexp];

    if (YOrN("Save rule to your config file?")) {
      print "Enter logical grouping for this stat (e.g. Client Stats): ";
      chomp(my $group = <STDIN>);

      print "Enter short description of the stat: ";
      chomp (my $desc = <STDIN>);

      $rule->[0] = $group;
      $rule->[1] = $desc;

      SaveRuleToConfigFile($rule);
    }

    push(@{$rules_g{groups}{$rule->[0]}}, $rule);
    $rules_g{stats}{$statName} = $rule;

    if (YOrN("Add stat to current plot?")) {
      my $axis = DoMenu({title => "Which y-axis",
                         prompt => "Select axis",
                         items => ["primary",
                                   "secondary"]});

      AddStat($statName, {axis => $axis});

    }

    last;

  }


} # LearnStat #


##############################################################################
## FindRegexpForStat - 
##
## This function will work with the user to come up with a regexp that will
## find the appropriate number 
##
##############################################################################
sub FindRegexpForStat {
  my ($text) = @_;

  print "\nWe will now try to generate a regular expression to get the stat that \n";
  print "you care about.  \n\n";
  sleep(2);
  
  # Decompose the string into a regexp that can accept varying numbers, but fixed strings
  my $t = $text;
  my @regexp;
  my @checkpoints;
  my @nums;
  my $pos;
  my $numR    = '[\d\.]+';
  my $numRCap = '([\d\.]+)';
  my $wordR   = '((?:[a-zA-Z]\w*\s?)+)';
  my $syms = '([:!@#\$%^&*(),.<>{}\\\|\/\?\[\]\-\_\+=\'"`~]+)';
  my $sanity = 100000;
  while (length($t) > 0 && $sanity--) {
    # print "pos: $pos, len: " . (length($t)) ."\n";
    if ($t =~ /^$wordR/) {
      # print "word: $1\n";
      my $word = $1;
      $word =~ s/\n/\\n/g;
      push(@regexp, $word);
      $t =~ s/^$wordR//;
    }
    elsif ($t =~ /^$syms/) {
      # print "Found sym: $1\n";
      my $sym = $1;
      $sym =~ s/([\|\(\)\[\]\+\-\*])/\\$1/g;
      push(@regexp, $sym);
      $t =~ s/^$syms//;
    }
    elsif ($t =~ /^\s+/) {
      push(@regexp, "\\s+");
      $t =~ s/^\s+//;
    }
    elsif ($t =~ /^\n/) {
      push(@regexp, "\\n");
      $t =~ s/^\n//;
    }
    elsif ($t =~ /^$numRCap/) {
      # Do the tracking so that we can 
      # print "Found num: $1\n";
      my $start = $pos;
      my $end = $start + length($1) - 1;
      push(@nums, {start => $start, 
                   length => length($1),
                   end => $end});
      push(@regexp, "$numR");
      push(@checkpoints, scalar(@regexp)-1);
      $t =~ s/^$numR//;
    }
    elsif ($t =~ /^(\d+)/) {
      # Do not track this number
      # print "Skip num: $1\n";
      push(@regexp, "\\d+");
      $t =~ s/^\d+//;
    }
    else {
      $t =~ s/^.//;
    }
    $pos = length($text) - length($t);
  }

  # print Dumper \@regexp;

  my $orig = $text;
  # Now overwrite part of each number with a tag
  my $i;
  for my $j (0 .. scalar(@checkpoints)-1) {
    $i = scalar(@checkpoints) - 1 - $j;
    my $start = $nums[$i]{start};
    my $len = $nums[$i]{length};
    my $tag = ('a'..'z')[int($i)/26] . ('a'..'z')[$i%26];
    my $padding = "." x ($len > 2 ? $len - 2 : 0);

    if (($len == 1) && (substr($text, $start-2, 2) eq "  ")) {
      substr($text, $start-1, $len+1) = "${BOLD}$padding$tag${NORMAL}";
    }
    else {
      substr($text, $start, $len) = "${BOLD}$padding$tag${NORMAL}";
    }
  }
  
  print $text;
  print "Choose two-letter tag in the above text for the stat to get: ";
  my $tag = <STDIN>;
  my $val = (ord(lc(substr($tag, 0, 1)))-ord('a')) * 26 + (ord(lc(substr($tag, 1, 1))) - ord('a'));
  if ($val < 0 || $val >= scalar(@nums)) {
    print "Select statistic tag is out of range\n";
    exit;
  }

  # Find the minimal regexp
  my $regexp;
  my $numPre = 1;
  while ($numPre < scalar(@regexp)) {
    $regexp = "";
    for my $i (0 .. $numPre-1) {
      $regexp .= $regexp[$i + $checkpoints[$val] - $numPre];
    }
    $regexp .= $numRCap;
    
    my @test = ($orig =~ /$regexp/g);
    
    if (scalar(@test) == 0) {
      Debug("Failed with regexp $regexp - this should not happen");
      print "Failed to automatically generate a regexp for that stat.  You will have to manually add it\n";
      return undef;
    }
    elsif (scalar(@test) == 1) {
      Debug("Found the regexp:  $regexp");
      return $regexp;
    }
    else {
      Debug("Found ". scalar(@test) ." matches with $regexp, trying again");
    }
    
    $numPre++;

  }

  return undef;

} # FindRegexpForStat #




##############################################################################
## ClearStats - 
##
##############################################################################
sub ClearStats {
  # my () = @_;

  close($outfile_g);
  OpenOutfile();

} # ClearStats #



##############################################################################
## PrintPrompt - Print out the prompt 
##
##############################################################################
sub PrintPrompt {
  # my () = @_;

  print "(${BOLD}a${NORMAL})dd (${BOLD}r${NORMAL})emove (${BOLD}s${NORMAL})ave (${BOLD}l${NORMAL})oad (${BOLD}C${NORMAL})lear (${BOLD}q${NORMAL})uit (${BOLD}n${NORMAL})ewRule (${BOLD}?${NORMAL}) help\n";

} # PrintPrompt #


##############################################################################
## DoMenu - 
##
##############################################################################
sub DoMenu {
  my ($options) = @_;

  my $val;
  while (1) {
    print "\n";
    print "${BOLD}$options->{title}${NORMAL}\n" if $options->{title};
    my $idx = 1;
    foreach my $item (@{$options->{items}}) {
      if (ref($item) eq "HASH") {
        printf("  %2d: %s\n", $idx, $item->{name});
      }
      else {
        printf("  %2d: %s\n", $idx, $item);
      }
      $idx++;
    }
    if ($options->{prompt}) {
      print "${BOLD}$options->{prompt}:${NORMAL} ";
    }
    else {
      print "${BOLD}Select item:${NORMAL} ";
    }

    $val = <STDIN>;
    if ($val > 0 &&
        $val <= @{$options->{items}}) {
      last;
    }
    print "${BOLD}Invalid value${NORMAL}\n";
  }
  
  $val--;
  my $selected;
  if (ref($options->{items}[$val]) eq "HASH") {
    if (defined($options->{items}[$val]{menu})) {
      return DoMenu($options->{items}[$val]{menu});
    }
    $selected = defined($options->{items}[$val]{value}) ?
        $options->{items}[$val]{value} : $options->{items}[$val]{name};
  }
  else {
    $selected = $options->{items}[$val];
  }

  return ($selected, $val) if wantarray;
  return $selected;

} # DoMenu #


##############################################################################
## YOrN - Ask a Y/N question 
##
##############################################################################
sub YOrN {
  my ($prompt) = @_;

  print "${BOLD}$prompt (Y/N): $NORMAL";
  my $ans = <STDIN>;
  return 1 if $ans =~ /^\s*y/i;
  return 0;

} # YOrN #



##############################################################################
## CollectStats - Go and get the stats 
##
##############################################################################
sub CollectStats {
  # my () = @_;

  my $s = \%selectedStats_g;

  my %output;
  foreach my $type (keys(%collectRules_g)) {
    my $handle = GetHandle($type);
    if (!defined($handle)) {
      Debug("Can't get handle for type $type");
      return;
    }
    foreach my $cmd (keys(%{$collectRules_g{$type}})) {
      $output{$type}{$cmd} = $handle->send($cmd);
      if (!defined($output{$type}{$cmd})) {
        print "$@\n";
        # $@ =~ /timed out/) {
        CloseHandle($type);
        if ($type =~ "lconn") {
          Fatal("At present, rs-plot can not handle failed NAB soldebug commands. You will have to restart the tool when the system is back in a sane state");
        }
        return;
      }
    }
  }

  my @stats;
  foreach my $name (sort {$s->{$a}{index} <=> $s->{$b}{index}} (keys(%{$s}))) {
    my $stat = $s->{$name};
    (Error("Missing output for $stat->{info}[3]:$stat->{info}[4], skipping $name") && next)
        if !defined($output{$stat->{info}[3]}{$stat->{info}[4]});

    my ($val) = ($output{$stat->{info}[3]}{$stat->{info}[4]} =~ /$stat->{info}[6]/);
    if ($args{debug}) {
      Debug("output: $output{$stat->{info}[3]}{$stat->{info}[4]}");
      Debug("regexp: $stat->{info}[6]");
      Debug("Extracted: $val");
    }
    if (defined($stat->{info}[7])) {
      Debug("Running eval on: $stat->{info}[7] with \$1=$1");
      $val = eval($stat->{info}[7]);
    }
    push(@stats, $val);
  }
  
  Debug(Dumper \@stats);
  return @stats;

} # CollectStats #


##############################################################################
## WriteStatsToDisk - 
##
##############################################################################
sub WriteStatsToDisk {
  my ($time, $stats) = @_;

  my $txt = join(", ", @{$stats});
  print $outfile_g "$time, $txt\n";

} # WriteStatsToDisk #


##############################################################################
## OpenOutfile - Open the stats file for writing 
##
##############################################################################
sub OpenOutfile {
  # my () = @_;
  
  open($outfile_g, ">", $args{outfile}) ||
      Fatal("Could not open $args{outfile}: $!");
  $outfile_g->autoflush;

} # OpenOutfile #



##############################################################################
## LoadRules - 
##
## This will load and parse the global rule file and the custom one if it is
## present 
##
##############################################################################
sub LoadRules {
  # my () = @_;

  $args{cfg_file} =~ s/^~/$ENV{HOME}/;

  LoadRuleFile("$FindBin::Bin/rs-plot-rules");
  LoadRuleFile($args{cfg_file}) if -r $args{cfg_file};

} # LoadRules #


##############################################################################
## LoadRuleFile - 
##
## Parse the rules in the specified file and store them in the rules_g hash 
##
##############################################################################
sub LoadRuleFile {
  my ($file) = @_;

  open(IN, "<", $file) || Fatal("Can't open rule file $file: $!");

  my $section = "";
  while (my $line = <IN>) {
    next if $line =~ /^\s*#/ || $line =~ /^\s*$/;

    if ($line =~ /^\s*\[(\w+)\]/i) {
      $section = lc($1);
      next;
    }

    next if $section eq "";
    
    if ($section eq "rules") {
      # Parse the rule
      my $origLine = $line;
      my @fields;
      while ($line !~ /^\s*$/) {
        if (my ($delim) = ($line =~ /^\s*(")/)) {
          if (my ($field) = ($line =~ /^\s*$delim(.*?)$delim\s*(,|$)/)) {
            $line =~ s/^\s*$delim(.*?)$delim\s*(,|$)//g;
            push(@fields, $field);
          }
          else {
            Fatal("Failed parsing rule: $origLine");
          }
        }
        else {
          if (my ($field) = ($line =~ /^\s*(.*?)\s*(,|$)/)) {
            $line =~ s/^\s*(.*?)\s*(,|$)//g;
            push(@fields, $field);
          }
          else {
            Fatal("Failed parsing rule: $origLine");
          }
        }
      }

      push(@{$rules_g{groups}{$fields[0]}}, \@fields);
      $rules_g{stats}{$fields[2]} = \@fields;

    }
    elsif ($section eq "statgroups") {
      my ($group, $rest) = ($line =~ /^\s*([\w\_\-\d\.\s]+?)\s*=\s*(.*?)\s*$/);
      if (!defined($group) || !defined($rest)) {
        Error("Malformed stat group definition: $line");
        next;
      }
      
      my @stats = ($rest =~ /\s*([\w\d\-\_\.]+:{[^}]+})/g);
      $savedConfigs_g{$group} = \@stats;

    }
  }

  #print Dumper \%savedConfigs_g;
  #print Dumper \%rules_g;
  close(IN);

} # LoadRuleFile #



##############################################################################
## GetHandle - 
##
## Return the requested handle type and create a session for it if it hasn't
## already been created 
##
##############################################################################
sub GetHandle {
  my ($type) = @_;
  my $lastDotTime = 0;

  if (!defined($handles_g{$type})) {

    my $actualType = $type;
    my $connStr;

    if ($actualType =~ /soldebug/) {
      $actualType = "soldebug";
      $connStr    = $type;
      $connStr    =~ s/^.*?:/:/g;
    }

    my $exp = new Solace::Expect(router => $args{router},
                                 type => $actualType,
                                 debug => $args{debug},
                                 log_stdout => $args{debug}) || 
                                     Fatal("Failed to create expect session of type $type");
    my $rc = $exp->connect();

    if (!defined($rc)) {
      my $t = time();
      if ($t - $lastDotTime > 5) {
        print ".";
        $printedDot_g = 1;
        $lastDotTime  = $t;
      }
      return undef;
    }
    elsif ($printedDot_g) {
      print "\n";
      PrintPrompt();
      $printedDot_g = 0;
    }

    if ($connStr) {
      $exp->send($connStr);
    }

    $handles_g{$type} = $exp;

  }

  return $handles_g{$type};

} # GetHandle #


##############################################################################
## CloseHandle - Close the handle for the specified type 
##
##############################################################################
sub CloseHandle {
  my ($type) = @_;

  delete($handles_g{$type});

} # CloseHandle #




##############################################################################
## RegenPlot - 
##
##############################################################################
sub RegenPlot {
  my ($plot) = @_;

  my $cmd = "plot ";

  my $s = \%selectedStats_g;
  
  return if scalar(keys(%$s)) == 0;

  my $lineType = $args{cb} ? "linespoints" : "lines";
  foreach my $name (sort {$s->{$a}{index} <=> $s->{$b}{index}} (keys(%{$s}))) {
    my $stat = $s->{$name};
    next if $s->{$name}{disable};
    my $axis = "x1" . ($stat->{axis} =~ /primary/i ? "y1" : "y2");
    my $idx = $stat->{index} + 2;
    $cmd .= "'$args{outfile}' using 1:$idx title '$stat->{info}[2]' with $lineType axes $axis,"
  }
  $cmd =~ s/,$//;
    
  print $plot "$cmd\n";

} # RegenPlot #



##############################################################################
## StartGnuplot - 
##
##############################################################################
sub StartGnuplot {

#  open my $olderr, ">&STDERR";
#  close(STDERR);
#  open(STDERR, ">", "/dev/null");


  my $plot;
  open($plot, "| gnuplot -noraise -persist >& /dev/null") || Fatal("Failed to start gnuplot: $!");
  $plot->autoflush;
  print $plot "set xdata time\n";
  print $plot "set timefmt \"%s\"\n";
  print $plot "set format x \"%H:%M:%S\"\n";
  print $plot "set yrange [0:]\n";
  print $plot "set y2range [0:]\n";
  print $plot "set y2tics\n";
  print $plot "set grid x y\n";
  
#  open STDERR, ">&", $olderr;

  return $plot;

} # StartGnuplot #


##--User Code End--##



##############################################################################
## ParseArgs - Will do all the argument parsing
##
##############################################################################
sub ParseArgs {
  
  # Options Parsing
  @allArgs = @ARGV;

  my %defaultArgs = %args;
  %args = ();

  # Converts position arguments to names
  my @posToName = (
              'router',
              'stats_or_groups',
  );

  # Converts position arguments to names
  my @posToType = (
              'string',
              'string',
  );

  # All required arguments
  my %requiredArgs = (
                       'router' => 1,
  );

  # All enum arguments
  my %enumArgs = (
  );

  # Cross ref of perl version of args to command line version
  my %perlToCmdArg = (
                       'interval' => 'interval',
                       'router' => 'router',
                       'outfile' => 'outfile',
                       'plot_interval' => 'plot-interval',
                       'cfg_file' => 'cfg-file',
                       'stats_or_groups' => 'stats-or-groups',
                       'list' => 'list',
                       'cb' => 'cb',
                       'debug' => 'debug',
                       'gen_completion' => 'gen-completion',
                       'help' => 'help',
                       'interactive' => 'interactive',
                       'quiet' => 'quiet',
                       'short_help' => 'short-help',
                       'tiny_help' => 'tiny-help',
                       'verbose' => 'verbose',
  );


  LearnArgsFromConfFile();

  my $result = GetOptions (
                           'interval=f' => \$args{interval},
                           'outfile=s' => \$args{outfile},
                           'plot-interval=f' => \$args{plot_interval},
                           'cfg-file=s' => \$args{cfg_file},
                           'list' => \$args{list},
                           'cb' => \$args{cb},
                           'debug' => \$args{debug},
                           'gen-completion' => \$args{gen_completion},
                           'help' => \$args{help},
                           'interactive' => \$args{interactive},
                           'quiet' => \$args{quiet},
                           'short-help' => \$args{short_help},
                           'tiny-help' => \$args{tiny_help},
                           'verbose' => \$args{verbose},
  );

  if (!$result) { exit(1); }


  # Positional argument processing

  my $posIdx = 0;
  while (@ARGV) {
    if ($posIdx >= 2) {
      last;
    }
    if ($posIdx == 1) {
      # Consume the remainder of @ARGV
      $args{$posToName[$posIdx]} = [];
      @{$args{$posToName[$posIdx]}} = @ARGV;
      @ARGV = ();
      if ($posToType[$posIdx] eq 'integer') {
        # Run through the list and convert text to numbers
        map {$_ = StrToNum($_, "Failed to convert $_ to number");}
          @{$args{$posToName[$posIdx]}};
      }
      last;
    }
  
    $args{$posToName[$posIdx]} = shift @ARGV;
    if ($posToType[$posIdx] eq 'integer') {
      $args{$posToName[$posIdx]} = 
         StrToNum($args{$posToName[$posIdx]}, "Failed to convert $args{$posToName[$posIdx]} to number");
    }
    delete $requiredArgs{$posToName[$posIdx]};
    $posIdx++;
  }
  @remainingArgs = @ARGV;
  @parsedArgs = @allArgs[0..(scalar(@allArgs)-scalar(@remainingArgs)-1)];

  if($#ARGV > -1) { 
    print "${BOLDr}Unrecognized argument(s):$NORMAL ";
    foreach (@ARGV) { print "$_ "; } print "\n";
    exit 1;
  }

  # Copy over all the arguments that were parsed
  foreach my $arg (keys(%args)) {
    if (defined $args{$arg}) {
      $parsedArgs{$arg} = 1;
    }
  }

  # Put back the default arguments
  foreach my $arg (keys(%defaultArgs)) {
    if (!defined($args{$arg})) {
      $args{$arg} = $defaultArgs{$arg};
    }
  }


  # Standard option processing

  if ($args{gen_completion}) {
    print "--interval --outfile --plot-interval --cfg-file --list --cb --debug --help --interactive --quiet --short-help --tiny-help --verbose ";
    exit;
  }

  if ($args{help}) {
    pod2usage(-verbose => 2);    
    exit;
  }
  if ($args{short_help}) {
    pod2usage(-verbose => 1);
    exit;
  }
  if ($args{tiny_help}) {
    my $info = GetArgInfo();
    print "$info->{Name} - $info->{ShortDescription}\n";
    exit;
  }
  my $showCmdLine = 0;
  if ($args{interactive}) {
    PromptForArgs(1, %args);
    $showCmdLine = 1;
  }
  
  # Check for missing required params
  foreach my $key (keys(%requiredArgs)) {
    if (defined $args{$key}) {
      delete $requiredArgs{$key};
    }
  }
  if (scalar(keys(%requiredArgs)) > 0) {
    print "\nMissing some required parameters\n";
    PromptForArgs(1, %requiredArgs);
    $showCmdLine = 1;
  }
  
  # Check that enums have valid values
  my $argInfo = GetArgInfo();
  foreach my $arg (keys(%enumArgs)) {
    if (defined $args{$arg}) {
      if (not defined $enumArgs{$arg}{$args{$arg}}) {
        print "\nInvalid value for argument $arg.  Valid values are:\n";
        foreach my $value (keys(%{$enumArgs{$arg}})) {
          print "  $value\n";
        }
        exit;
      }
    }
  }
  
  if ($showCmdLine) {
    # Output the command line for this
    DisplayCommandLine();
  }

} # ParseArgs


##############################################################################
## PromptForArgs - Will ask the user for values for various arguments
##
## skipAutoArgs: When true, it will not prompt for --interactive, --debug,
##               --quiet, --verbose or --help
##
##############################################################################
sub PromptForArgs {
  my ($skipAutoArgs, %argsForPrompting) = @_;
  my $argInfo = GetArgInfo();
  
  print "\nInteractive Input:\n\n";
  foreach my $arg (@{$argInfo->{Args}}) {
    my $name = $arg->{Name};
    my $perlName = $arg->{PerlName};
    if (not exists $argsForPrompting{$perlName}) {
      next;
    }
    if ($skipAutoArgs && 
        ($name =~ /^(debug|interactive|quiet|verbose|help|gen-completion)$/)) {
      next;
    }
    my $desc = $arg->{Description};
    my $space = " " x (length($name) + 3);
    $desc =~ s/(.{1,75 - length($name)})(?:\s|$|\n)/$1\n$space/g;
    my $prompt = "\n$BOLD$name$NORMAL - $arg->{Description}";
    my $default = '';
    my $defVal = '';
    if (defined $args{$perlName}) {
      $default = " [$args{$perlName}]";
      $defVal = $args{$perlName};
    }
    elsif ($arg->{Default}) {
      $default = " [$arg->{Default}]";
      $defVal = $arg->{Default};
    }
    while (1) {
      if ($arg->{ValType} eq 'boolean') {
        print $prompt . "\nEnter value for flag (undef, 0 or 1)$default: ";
      }
      elsif ($arg->{ValType} =~ /integer|float/) {
        print $prompt . "\nEnter numeric value$default: ";
      }
      elsif ($arg->{ValType} eq 'enum') {
        print $prompt . "\nSelect value: ";
      }
      else {
        print $prompt . "\nEnter value$default: ";
      }
      my $response;
      if ($arg->{ValType} eq 'enum') {
        print "\n";
        $default = '';
        my $num = 1;
        my $defaultNum;
        foreach my $val (@{$arg->{EnumList}}) {
          print "  $num: $val\n";
          if ($val eq $defVal) {
            $default = "[$num]";
            $defaultNum = $num;
          }
          $num++;
        }
        while (1) {
          print "Select number$default: "; 
          chomp($response = <STDIN>);
          if ($response eq '') {
            $response = defined $defaultNum ? $defaultNum : 0;
          }
          if ($response >= 1 &&
              $response <= scalar(@{$arg->{EnumList}})) {
            $response = $arg->{EnumList}[$response-1];
            last;
          }
          print "Invalid selection - try again\n";
        }
      }
      else {
        chomp($response = <STDIN>);
      }
      if ($arg->{Required} && 
          (not defined $args{$perlName}) &&
          $response eq '') {
        print "You must enter a value for this argument\n";
      }
      else {
        if ($response eq '' && 
            defined $args{$perlName}) {
          # Keep the same value
        }
        elsif ($response eq '' && 
               defined $arg->{Default}) {
          $args{$perlName} = $arg->{Default};
        }
        else {
          if ($arg->{ValType} eq 'integer') {
            $args{$perlName} =
              StrToNum($response, "Failed to convert $response to number");
          }
          else {
            $args{$perlName} = $response;
          }
        }
        if (($arg->{ValType} eq 'boolean') && 
            (($args{$perlName} eq 'undef') || ($args{$perlName}) eq ''))  {
          $args{$perlName} = undef;
        }
        last;
      }
    }
  }

}



##############################################################################
## LearnArgsFromConfFile - This will open the appropriate .conf file to get
##                       additional arguments
##
##############################################################################
sub LearnArgsFromConfFile {
  my $homeDir;
  if (exists $ENV{'HOME'}) {
    $homeDir = $ENV{'HOME'};
  } else {
    # Some flavour of Windows? Try this:
    $homeDir = $ENV{'USERPROFILE'};
  }
  return if !(-e "$homeDir");
  return if !(-e "$homeDir/.scripts");

  my $conf = "$homeDir/.scripts/rs-plot.conf";
  return if !(-e $conf);

  # The file exists - suck it in and parse out the goodness
  open(IN, $conf) || return;
  my @data = <IN>;
  close(IN);

  my $section = "";
  my $quiet = 0;
  foreach my $line (@data) {
    if ($line =~ /^\s*\[([^\]]+)\]/) {
      $section = $1;
    }
    elsif ($section =~ /^(args)|(command-line-args)|(cmd-line-args)|(cmdline-args)/i || $section eq "") {
      if ($line =~ /^\s*([\w\-\_\d]+)\s*=\s*([^\n\s\#\;]+)/) {
        my $arg = $1;
        my $val = $2;
        print "Defaulting argument --$1 to $2 from .conf file\n" unless $quiet;
        # Put the arg at the head of the arg list
        unshift(@ARGV, "--$arg=$val");
      }
      elsif ($line =~ /^\s*([\w\-\_\d]+)\s*$/) {
        my $arg = $1;
        print "Defaulting flag --$1 to on from .conf file\n" unless $quiet;
        # Put the arg at the head of the arg list
        unshift(@ARGV, "--$arg");
      }
    }
    elsif ($section =~ /^global-?settings/i) {
      if ($line =~ /^\s*([\w\-\_\d]+)\s*=\s*([^\n\s\#\;]+)/) {
        my $arg = $1;
        my $val = $2;
        if (lc($arg) eq "quiet") {
          $quiet = $val;
          unshift(@ARGV, "--quiet") if $val;
        }
      }
    }
  }
  
} # LearnArgsFromConfFile


##############################################################################
## GetArgInfo - This will return all the script information in perl
##              struct form.
##
##############################################################################
sub GetArgInfo {

  my $cfgInfo = {
             'PositionalListLocation' => 1,
             'SuperScriptRevision' => '3622',
             'ShortDescription' => 'Get stats from the router and plot them',
             'ParsingType' => 'unordered',
             'Description' => 'Poll a router for various stats and plot them on a graph.  It will also keep a timestamped file of the stats collected.  The list of stats that can be polled is stored in devtools/bin/rs-plot-rules.  You can load custom rules by putting them in your custom rule file in ~/.rs-plot-rules.  See devtools/bin/rs-plot-rules for the format.
',
             'Name' => 'rs-plot',
             'Args' => [
                         {
                           'Type' => 'named',
                           'Default' => '1',
                           'Required' => 0,
                           'ValType' => 'float',
                           'Description' => 'Polling interval',
                           'Name' => 'interval',
                           'PerlName' => 'interval'
                         },
                         {
                           'Type' => 'positional',
                           'Required' => 1,
                           'ValType' => 'string',
                           'Description' => 'Router to poll',
                           'Name' => 'router',
                           'PerlName' => 'router'
                         },
                         {
                           'Type' => 'named',
                           'Default' => '/tmp/rs-plot.txt',
                           'Required' => 0,
                           'ValType' => 'string',
                           'Name' => 'outfile',
                           'Description' => 'File to be written with iostat stats',
                           'PerlName' => 'outfile'
                         },
                         {
                           'Type' => 'named',
                           'Default' => '5',
                           'Required' => 0,
                           'ValType' => 'float',
                           'Description' => 'How frequently, in seconds, to regenerate the plot',
                           'Name' => 'plot-interval',
                           'PerlName' => 'plot_interval'
                         },
                         {
                           'Type' => 'named',
                           'Default' => '~/.rs-plot',
                           'Required' => 0,
                           'ValType' => 'string',
                           'Name' => 'cfg-file',
                           'Description' => 'Path to the rs-plot config file',
                           'PerlName' => 'cfg_file'
                         },
                         {
                           'Type' => 'positional-list',
                           'Default' => [],
                           'Required' => 0,
                           'ValType' => 'string',
                           'Description' => 'List of stats or stat groups to start with',
                           'Name' => 'stats-or-groups',
                           'PerlName' => 'stats_or_groups'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Default' => 0,
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'List all stats and stat-groups',
                           'Name' => 'list',
                           'PerlName' => 'list'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Default' => 0,
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Name' => 'cb',
                           'Description' => 'Colour blind mode - this will use gray-scale and use different markers at each point',
                           'PerlName' => 'cb'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Turn on all debug output.',
                           'Name' => 'debug',
                           'PerlName' => 'debug'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Prints out completion info for the parameters',
                           'Name' => 'gen-completion',
                           'PerlName' => 'gen_completion'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out usage info for this script',
                           'Name' => 'help',
                           'PerlName' => 'help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Query the user for values for each of the arguments, providing help for each.  This will print out the appropriate command line for future reference before executing the script.',
                           'Name' => 'interactive',
                           'PerlName' => 'interactive'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Reduce the amount of output to the bare minimum.',
                           'Name' => 'quiet',
                           'PerlName' => 'quiet'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out usage summary for this script',
                           'Name' => 'short-help',
                           'PerlName' => 'short_help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out one line description for this script',
                           'Name' => 'tiny-help',
                           'PerlName' => 'tiny_help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out more user-level output',
                           'Name' => 'verbose',
                           'PerlName' => 'verbose'
                         }
                       ],
             'PositionalListIdx' => undef
           };

  return $cfgInfo;

} # GetArgInfo


##############################################################################
## DisplayCommandLine - This will print out the command line for the
##                      current arguments
##
##############################################################################
sub DisplayCommandLine {

  my $argInfo = GetArgInfo();

  # my $output = "$argInfo->{Name} ";
  my $output = "$0 ";
  my $positional = '';

  foreach my $arg (@{$argInfo->{Args}}) {
    my $name = $arg->{Name};
    my $perlName = $arg->{PerlName};
    if (not defined $args{$perlName}) {
      next;
    }
    if (defined $arg->{Default} && 
        $args{$perlName} eq $arg->{Default}) {
      next;
    }
    if ($perlName eq 'interactive') {
      next;
    }

    my $value = $args{$perlName};
    if ($value =~ /\s/) {
      $value = "'$value'";
    }
    
    if ($arg->{Type} eq 'named') {
      if ($arg->{ValType} eq 'boolean') {
        if (defined $args{$perlName}) {
          if ($args{$perlName} == 0) {
            $output .= "--no-$name ";
          }
          else {
            $output .= "--$name ";
          }
        }
      }
      else {
        $output .= "--$name=$value ";
      }
    }
    else {
      if (ref $value eq 'ARRAY') {
        if (scalar(@{$value} > 1) || $value->[0] ne '') {
          $positional .= "@{$value} ";
        }
      }
      else {
        $positional .= "$value ";
      }
    }

  }
  
  print "Command line:\n";
  print "$output$positional\n\n";
  # `history -s $output$positional`;

} # DisplayCommandLine #


##############################################################################
## Log - This will output messages of various levels
##
##############################################################################
sub Log {
  my ($level, $message, $addCaller) = @_;

  my $outputMsg = 0;
  if (!$args{quiet}) {
    if ($level eq "DEBUG") {
      if ($args{debug}) {
        $outputMsg = 1;
      }
    }
    elsif ($level eq "INFO") {
      if ($args{debug} || $args{verbose}) {
        $outputMsg = 1;
      }
    }
    elsif ($level eq "WARN") {
        $outputMsg = 1;
    }
  }

  if (($level eq "ERROR") || ($level eq "FATAL") || ($level eq "MSG")) {
    $outputMsg = 1;
  }
  
  if ($outputMsg) {
    if (($level ne "MSG") || $addCaller) {
      print "$level: ";
    }
    if ($addCaller) {
      my @caller = caller(1);
      $caller[1] =~ s/^.*\///;
      print "$caller[1]:$caller[2]: ";
    }
    print "$message\n";
  }

  if ($level eq "FATAL") {
    exit(1);
  }

} # Log

sub Fatal { Log("FATAL", @_) };
sub Error { Log("ERROR", @_) };
sub Warn  { Log("WARN", @_) };
sub Info  { Log("INFO", @_) };
sub Debug { Log("DEBUG", @_) };
sub Msg   { Log("MSG", @_) };



##############################################################################
## StrToNum - This will convert all types of strings into numbers
##
##############################################################################
sub StrToNum {
  my ($string, $failMsg) = @_;

  if ($string !~ 
      /^([-+]?_*[1-9][0-9_]*  |
         0x_*[0-9a-f][0-9a-f_]* |
         0b_*[01][01_]*         |
         0[0-7_]*)$
      /xi) {
    Fatal($failMsg);
  }

  my $num = eval($string);
  
  if ($@) {
    Fatal($@);
  }

  return $num;

}
  



BEGIN {
  use FindBin;
  use lib "/usr/local/devtools/bin/../lib/perl";
  eval("require 'Solace/Usage.pm'; Solace::Usage::logUsage();");
}

    
 

__END__

=head1 NAME

rs-plot

=head1 DESCRIPTION

Poll a router for various stats and plot them on a graph.  It will also keep a timestamped file of the stats collected.  The list of stats that can be polled is stored in devtools/bin/rs-plot-rules.  You can load custom rules by putting them in your custom rule file in ~/.rs-plot-rules.  See devtools/bin/rs-plot-rules for the format.


=head1 OPTIONS

rs-plot [OPTIONS] <router> [stats-or-groups ...] 

Where:

=over

=item router ... (string) B<*Required*>

Router to poll

=item stats-or-groups ... (zero or more strings)

List of stats or stat groups to start with
[Default: ]

=item --interval=<float>

Polling interval
[Default: 1]

=item --outfile=<string>

File to be written with iostat stats
[Default: /tmp/rs-plot.txt]

=item --plot-interval=<float>

How frequently, in seconds, to regenerate the plot
[Default: 5]

=item --cfg-file=<string>

Path to the rs-plot config file
[Default: ~/.rs-plot]

=item --list

List all stats and stat-groups

=item --cb

Colour blind mode - this will use gray-scale and use different markers at each point

=item --interactive

Query the user for values for each of the arguments, providing help for each.  This will print out the appropriate command line for future reference before executing the script.

=item --help, --short-help, --tiny-help

Display various levels of usage information

=item --quiet, --verbose, --debug

Control the amount of information printed during execution

=back

