#!/usr/bin/perl
#
# Script: rs-trace-client
#
# This script will log into the specified router and attempt to trace the route
# of the specified client through the L2 and L3 network.  It will use SNMP
# along with LLDP and CDP information to figure out the path.
# 
#
# The framework of the script was autogenerated by version 3017 of
# /usr/local/devtools/bin/super-script.
#
#############################################################################


use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;
use Pod::Usage;

use constant BOLD    => "\e[1m";
use constant NORMAL  => "\e[0m";

my $BOLD   = BOLD;
my $NORMAL = NORMAL;
my $BOLDr  = "[31m[1m";  # Red
my $BOLDg  = "[32m[1m";  # Green

# Main hash - all the argument values will be in here after parsing
my %args = (
            router => '',
            client_name => '',
            snmp_community => 'public',
            z => '0',
            debug => undef,
            gen_completion => undef,
            help => undef,
            interactive => undef,
            quiet => undef,
            short_help => undef,
            tiny_help => undef,
            verbose => undef,
);

# Arrays to hold the parsed and unparsed args
my @remainingArgs;
my @allArgs;
my @parsedArgs;
my %parsedArgs;

ParseArgs();

##--User Code Start--##

use lib "/usr/local/devtools/lib/perl";
use lib "/home/efunnekotter/devtools/efunnekotter/perl/lib";
use SNMP::Info::LLDP;
use SNMP::Info::CDP;
use SNMP::Info::Layer2;
use SNMP::Info::Layer3;
use Solace::Simple;



# Call main - the start of the script
Main();

##############################################################################
## Main - Starting point for the script
##
##############################################################################
sub Main {

  if ($args{z}) {
    MakeTarball();
    exit;
  }

  my $router     = new Solace::Simple(router => $args{router});
  my $clientInfo = GetClientInfo($router, $args{client_name});
  my $lldpInfo   = GetLldpInfo($router);

  # print Dumper $clientInfo;
  # print Dumper $lldpInfo;
  
  my $route = TraceRoute($clientInfo, $lldpInfo);
  my $text  = RenderRouteAscii($route);

  # print Dumper $route;

  print $text;

}


##############################################################################
## TraceRoute - Trace the path through the L2/L3 network 
##
##############################################################################
sub TraceRoute {
  my ($clientInfo, $lldpInfo) = @_;

  my @route;

  if (!defined($lldpInfo->{$clientInfo->{ifIdx}})) {
    Fatal("There is no LLDP information for port ID $clientInfo->{ifIdx} on the router");
  }
  
  if (length(@{$lldpInfo->{$clientInfo->{ifIdx}}}) > 1) {
    Warn("There are multiple NAB ports in a LAG on the Solace router.  Only the first path will be displayed");
  }
 
  my $lldpPortInfo = $lldpInfo->{$clientInfo->{ifIdx}}[0];
  
  if (!defined($lldpPortInfo->{mgmt_addr})) {
    Fatal("The management IP of the first switch in the route is unknown.  LLDP on the Solace router did not discover it correctly.");
  }

  my $currMac            = $clientInfo->{nextHop};
  my $currSwitchIp       = $lldpPortInfo->{mgmt_addr};
  my $currSwitchIngrIdx  = $lldpPortInfo->{port_id};

  push(@route, {type         => "message router",
                managementIp => GetIpAddrByHostName($args{router}),
                ingressPort  => undef,
                egressPort   => $clientInfo->{ifIdx},
                name         => $clientInfo->{routerHostName},
                vendor       => "solace systems",
                model        => $clientInfo->{routerModel},
       });

  my $sanity = 100;

  while ($sanity--) {

    my $switchInfo = GetSwitchInfo($currSwitchIp, $args{snmp_community});

    my $hop = {type         => "",
               managementIp => $currSwitchIp,
               ingressPort  => $currSwitchIngrIdx,
               egressPort   => "",
               name         => $switchInfo->{name},
               vendor       => $switchInfo->{vendor},
               model        => $switchInfo->{model}};
    push(@route, $hop);

    my $egrIf;

    if (defined($switchInfo->{localMacs}{$currMac})) {
      # We have reached a router - first try to find the IP in its ARP table
      my $mac = $switchInfo->{arpTable}{$clientInfo->{ip}};
      
      $hop->{type} = "ip router";
      if (defined $mac) {
        $egrIf   = $switchInfo->{ethRouting}{$mac};
        $currMac = $mac;
      }
      else {
        # Otherwise, do a routing table lookup
        # print Dumper $switchInfo->{ipRouting};
        my ($nextHop, $isNextHopARouter, $ifIdx) = 
            GetNextHop($switchInfo->{ipRouting}, $clientInfo->{addr});
        $egrIf = $ifIdx;
      }
    }
    else {
      # Traversing a switch - lookup the egress interface
      $hop->{type} = "ethernet switch";
      $egrIf = $switchInfo->{ethRouting}{$currMac};
    }

    Fatal("Can't find port for $clientInfo->{ip}/$egrIf on $currSwitchIp") if (!defined($egrIf));

    $hop->{egressPort} = $egrIf;

    my $lldp = $switchInfo->{lldp}{$egrIf};

    if (!defined $lldp) {
      # print "Reached the client or router/switch that does not have LLDP enabled\n";
      return \@route;
    }
    else {
      # print "Found next hop: $lldp->{ip} on port $lldp->{port}\n";
      $currSwitchIp      = $lldp->{ip};
      $currSwitchIngrIdx = $lldp->{port};
    }

  }

  return \@route;

} # TraceRoute #


##############################################################################
## GetSwitchInfo - 
##
## This will extract the model, vendor, LLDP/CDP info, L3 and L2 tables 
##
##############################################################################
sub GetSwitchInfo {
  my ($ip, $community) = @_;

  my %switchInfo;

  my $snmp = new SNMP::Info ( 
    AutoSpecify => 1,
    DestHost    => $ip, 
    Community   => $args{snmp_community},
    Version     => 2,
  );

  $switchInfo{model}  = $snmp->model();
  $switchInfo{vendor} = $snmp->vendor();
  $switchInfo{name}   = $snmp->name();
    
  if (!defined $switchInfo{vendor}) {
    ($switchInfo{vendor}) = ($snmp->class() =~ /::([^:]+)$/);
  }
    
  $switchInfo{lldp}       = GetSwitchLldpInfo($snmp);
  $switchInfo{arpTable}   = GetSwitchArpTable($snmp);
  $switchInfo{localMacs}  = GetSwitchMacAddrs($snmp);
  $switchInfo{ipRouting}  = GetSwitchIpRoutingTable($snmp);
  $switchInfo{ethRouting} = GetSwitchEthRoutingTable($snmp);
    
  
  return \%switchInfo;

} # GetSwitchInfo #


##############################################################################
## GetSwitchMacAddrs - 
##
##############################################################################
sub GetSwitchMacAddrs {
  my ($snmp) = @_;

  my $iMacs = $snmp->i_mac();
  
  my %macs;
  foreach my $key (keys(%{$iMacs})) {
    next if !defined $iMacs->{$key};
    $macs{$iMacs->{$key}} = $key;
  }

  return \%macs;

} # GetSwitchMacAddrs #


##############################################################################
## GetSwitchArpTable - 
##
##############################################################################
sub GetSwitchArpTable {
  my ($snmp) = @_;

  my %arp;
  my $netAddr = $snmp->at_netaddr();
  my $macAddr = $snmp->at_paddr();

  foreach my $iid (keys(%{$netAddr})) {
    $arp{$netAddr->{$iid}} = $macAddr->{$iid};
  }

  return \%arp;

} # GetSwitchArpTable #



##############################################################################
## GetSwitchIpRoutingTable - Get the routing table from the switch 
##
##############################################################################
sub GetSwitchIpRoutingTable {
  my ($snmp) = @_;
  
  my $keys  = $snmp->ipr_route();
  my $ifs   = $snmp->ipr_if();
  my $types = $snmp->ipr_type();
  my $dests = $snmp->ipr_dest();
  my $masks = $snmp->ipr_mask();

  my @tbl;
  foreach my $ip (keys(%{$keys})) {

    my $addr = 0;
    map {$addr = ($addr << 8) + $_;} split(/\./, $ip);

    my $maskBin = 0;
    map {$maskBin = ($maskBin << 8) + $_;} split(/\./, $masks->{$ip});

    my $maskLen = 32;
    my $tmpMask = $maskBin;
    while ($maskLen) { last if ($tmpMask & 1); $tmpMask >>= 1; $maskLen--; }

    my $nextHopIp = 1;
    my $nextHop;
    if ($types->{$ip} eq 'direct') {
      # Get the MAC for the next hop
      $nextHopIp = 0;
      my $netAddr = $snmp->at_netaddr();
      my $macAddr = $snmp->at_paddr();
      foreach my $iid (keys(%{$netAddr})) {
        # print "Checking for next hop IP $dests->{$ip}: $netAddr->{$iid}\n";
        if ($netAddr->{$iid} eq $ip) {
          $nextHop = $macAddr->{$iid};
          last;
        }
      }
    }
    else {
      $nextHop = $ip;
    }

    push(@tbl, {ip          => $ip, 
                addr        => $addr, 
                maskLen     => $maskLen,
                mask        => $maskBin,
                isNextHopIp => (($ip =~ /:/) ? 0 : 1),
                nextHop     => $nextHop,
                dest        => $dests->{$ip},
                type        => $types->{$ip},
                ifIdx       => $snmp->interfaces()->{$ifs->{$ip}}});

  }

  return \@tbl;

} # GetSwitchIpRoutingTable #


##############################################################################
## GetSwitchEthRoutingTable - Get the mapping of MACs to IFs 
##
##############################################################################
sub GetSwitchEthRoutingTable {
  my ($snmp) = @_;

  my $interfaces = $snmp->interfaces();
  my $fw_mac     = $snmp->fw_mac();
  my $fw_port    = $snmp->fw_port();
  my $bp_index   = $snmp->bp_index();

  my %tbl;
  foreach my $fw_index (keys %$fw_mac){
    my $mac   = $fw_mac->{$fw_index};
    my $bp_id = $fw_port->{$fw_index};

    next if !defined $bp_id;

    my $iid    = $bp_index->{$bp_id};

    next if !defined $iid;

    my $port   = $interfaces->{$iid};
    $tbl{$mac} = $port;
  } 
  
  return \%tbl;

} # GetSwitchEthRoutingTable #


##############################################################################
## GetSwitchLldpInfo - Retrieves the LLDP table from the specified switch 
##
##############################################################################
sub GetSwitchLldpInfo {
  my ($snmp) = @_;

  my %lldpInfo;

  my $interfaces    = $snmp->interfaces();

  if ($snmp->hasLLDP()) {
    my $lldp_if       = $snmp->lldp_if();
    my $lldp_ip       = $snmp->lldp_ip();
    my $lldp_port     = $snmp->lldp_port();
    
    foreach my $lldp_key (keys %$lldp_ip){
      my $iid           = $lldp_if->{$lldp_key};
      my $port          = $interfaces->{$iid};
      my $neighbor      = $lldp_ip->{$lldp_key};
      my $neighbor_port = $lldp_port->{$lldp_key};
      $lldpInfo{$port}  = {ip => $neighbor,
                           port => $neighbor_port};
    }
  } 

  if ($snmp->hasCDP()) {
    my $interfaces = $snmp->interfaces();
    my $c_if       = $snmp->c_if();
    my $c_ip       = $snmp->c_ip();
    my $c_port     = $snmp->c_port();
  
    foreach my $cdp_key (keys %$c_ip) {
      my $iid           = $c_if->{$cdp_key};
      my $port          = $interfaces->{$iid};
      my $neighbor      = $c_ip->{$cdp_key};
      my $neighbor_port = $c_port->{$cdp_key};
      $lldpInfo{$port}  = {ip => $neighbor,
                           port => $neighbor_port};
    }  
  }
   
  return \%lldpInfo;

} # GetLldpInfo #


##############################################################################
## GetIpAddrByHostName - 
##
##############################################################################
sub GetIpAddrByHostName {
  my ($name) = @_;

  my $raw_addr = (gethostbyname($name))[4];
  my @octets = unpack("C4", $raw_addr);
  return join(".", @octets);

} # GetIpAddrByHostName #



##############################################################################
## GetClientInfo - 
##
## This will connect to the router to find out some routing information about
## the specified client 
##
##############################################################################
sub GetClientInfo {
  my ($router, $client) = @_;

  my $connInfo    = $router->cli("show client $client connections");
  my ($ip, $port) = ($connInfo =~ /tcp\s+\d+\s+\d+\s+(\d+\.\d+\.\d+\.\d+):(\d+)/);

  Fatal("Failed to find IP address of client $client") if (!defined($ip));

  my $addr = 0;
  map {$addr = ($addr << 8) + $_;} split(/\./, $ip);

  my $routeTbl = GetRoutingTable($router);

  my ($nextHop, $isNextHopARouter, $ifIdx) = GetNextHop($routeTbl, $addr);

  if (!defined($nextHop)) {
    Error("Failed to find a next hop in the routing table for client $client with IP $ip");
  }

  my $response = $router->cli("show hostname");
  my ($hostname) = ($response =~ /^.*?:\s([^\r\n]*)/);

  $response = $router->cli("show hardware");
  my ($model) = ($response =~ /Platform:\s*([^\r\n]*)/);

  return {ip               => $ip,
          port             => $port,
          addr             => $addr,
          nextHop          => $nextHop,
          isNextHopARouter => $isNextHopARouter,
          ifIdx            => $ifIdx,
          routerHostName   => $hostname,
          routerModel      => $model};

} # GetClientInfo #


##############################################################################
## GetRoutingTable - This will extract the routing table from soldebug 
##
##############################################################################
sub GetRoutingTable {
  my ($router) = @_;

  $router->soldebug(":lconn 1");
  my $tbl = $router->soldebug("netstat_route");

  my @routeTbl;
  foreach my $line (split(/\n/, $tbl)) {
    last if ($line =~ /Per Interface Route/);
    my ($ip, $mask, $nextHop, $ifIdx) = 
        ($line =~ /(\d+\.\d+\.\d+\.\d+)\/(\d+)\s+((?:\d+\.\d+\.\d+\.\d+)|(?:[\d\w]{2}:[\d\w]{2}:[\d\w]{2}:[\d\w]{2}:[\d\w]{2}:[\d\w]{2}))?\s+\d{8}\s\w+\s+\d+\s+(\d+)/);
    if (defined($ip)) {
      my $addr = 0;
      map {$addr = ($addr << 8) + $_;} split(/\./, $ip);
      push(@routeTbl, {ip          => $ip, 
                       addr        => $addr, 
                       maskLen     => $mask,
                       mask        => ($mask == 0) ? 0 : (~((1 << $mask) - 1)),
                       isNextHopIp => (($ip =~ /:/) ? 0 : 1),
                       nextHop     => $nextHop,
                       ifIdx       => $ifIdx});
    }
  }

  return \@routeTbl;

} # GetRoutingTable #


##############################################################################
## GetNextHop - 
##
## Do a longest prefix match (and resolve to MAC address) the passed in IP 
##
##############################################################################
sub GetNextHop {
  my ($rtrTbl, $ip) = @_;

  my $maskLen = -1;
  my $foundEntry;

  foreach my $entry (@{$rtrTbl}) {
    if ($entry->{addr} == ($ip & $entry->{mask})) {
      if ($maskLen < $entry->{maskLen}) {
        $foundEntry = $entry;
        $maskLen = $entry->{maskLen};
      }
    }
  }

  my $isNextHopRouter = 0;
  if (defined $foundEntry) {
    if ($foundEntry->{isNextHopIp}) {
      $isNextHopRouter = 1;
      foreach my $entry (@{$rtrTbl}) {
        my $nextHopAddr = 0;
        map {$nextHopAddr = ($nextHopAddr << 8) + $_;} split(/\./, $foundEntry->{nextHop});
        if ($entry->{maskLen} == 32 &&
            $entry->{addr} == $nextHopAddr) {
          $foundEntry = $entry;
          last;
        }
      }
    }
  }
  else {
    return (undef, undef, undef);
  }

  return ($foundEntry->{nextHop}, $isNextHopRouter, $foundEntry->{ifIdx});

} # GetNextHop #


##############################################################################
## GetLldpInfo - Request the LLDP table from the router 
##
##############################################################################
sub GetLldpInfo {
  my ($router) = @_;

  $router->soldebug(":lconn 1");

  my $info = $router->soldebug("lldp_show");

  my $currIf;
  my $currInfoBlock;
  my %lldpInfo;
  foreach my $line (split(/\n/, $info)) {
    if ($line =~ /Port (\d+) Information:/) {
      $currIf = $1;
      $currInfoBlock = {};
      push(@{$lldpInfo{$currIf}}, $currInfoBlock);
      next;
    }
    elsif ($line =~ /^\s+([\w_]+):\s+([^\r\n]*)/) {
      $currInfoBlock->{$1} = $2;

      if ($1 eq "lag_if_idx") {
        my $lagPort = $2;
        if ($lagPort != -1) {
          push(@{$lldpInfo{$lagPort}}, $currInfoBlock);
        }
      }
    }
  }

  return \%lldpInfo;

} # GetLldpInfo #


##############################################################################
## RenderRouteAscii - 
##
##############################################################################
sub RenderRouteAscii {
  my ($route) = @_;

  my $text = "\n";

  my $boxWidth = 0;

  foreach my $r (@{$route}) {
    my @reqWidth;
    $reqWidth[0] = (length($r->{name}) < 38) ? (length($r->{name}) * 2) : length($r->{name});
    $reqWidth[1] = length($r->{vendor}) + length($r->{type}) + 1;
    $reqWidth[2] = length($r->{model}) + 7;
    $reqWidth[3] = length($r->{managementIp}) + 4;
    
    foreach my $w (@reqWidth) {
      $boxWidth = $w if $w > $boxWidth;
    }
  }

  foreach my $r (@{$route}) {
    if (defined($r->{ingressPort})) {
      $text .= sprintf("  %sv %s\n", " " x ($boxWidth/2), $r->{ingressPort});
    }
    my $type = "$r->{vendor} $r->{type}";
    $type =~ s/(\w+)/\u\L$1/g;

    $text .= sprintf(".-%s%s-.\n", $r->{name}, "-" x ($boxWidth - length($r->{name})));
    $text .= sprintf("| %s%s |\n", $type, " " x ($boxWidth - (length($type))));
    $text .= sprintf("| Model: %s%s |\n", $r->{model}, " " x ($boxWidth - (length($r->{model}) + 7)));
    $text .= sprintf("| %sIP: %s |\n", " " x ($boxWidth - (length($r->{managementIp}) + 4)), $r->{managementIp});
    $text .= sprintf("'-%s-'\n", "-" x $boxWidth);
    $text .= sprintf("  %s| %s\n", " " x ($boxWidth/2), $r->{egressPort});
    $text .= sprintf("  %s|\n", " " x ($boxWidth/2));
    $text .= sprintf("  %s|\n", " " x ($boxWidth/2));
  }

  $text .= sprintf("  %sv\n", " " x ($boxWidth/2));
  my $end = "Client or untraceable network";
  $text .= sprintf("  %s%s\n", " " x (($boxWidth/2) - length($end)/2), $end);

  return $text;

} # RenderRouteAscii #


sub MakeTarball {

  `mkdir -p /tmp/rtc.$$`;
  `rm -rf /tmp/rtc.$$/*`;

  `cp $0 /tmp/rtc.$$`;

  foreach my $file (keys(%INC)) {

    if ($INC{$file} =~ /perl5/) {
      next;
    }

    print "File $file from $INC{$file}\n";
    `cp $INC{$file} /tmp/rtc.$$`;
    
  }

  my $dir = `pwd`;
  chomp($dir);

  chdir("/tmp/rtc.$$");
  `tar -zcf rtc.tgz *`;
  `mv rtc.tgz $dir/rs-trace-client.tgz`;

  `rm -rf /tmp/rtc.$$`;

  print "Created tarball $dir/rs-trace-client.tgz.\n";


} # MakeTarball #




##--User Code End--##



##############################################################################
## ParseArgs - Will do all the argument parsing
##
##############################################################################
sub ParseArgs {
  
  # Options Parsing
  @allArgs = @ARGV;

  my %defaultArgs = %args;
  %args = ();

  # Converts position arguments to names
  my @posToName = (
              'router',
              'client_name',
  );

  # Converts position arguments to names
  my @posToType = (
              'string',
              'string',
  );

  # All required arguments
  my %requiredArgs = (
                       'router' => 1,
                       'client_name' => 1,
  );

  # All enum arguments
  my %enumArgs = (
  );

  # Cross ref of perl version of args to command line version
  my %perlToCmdArg = (
                       'router' => 'router',
                       'client_name' => 'client-name',
                       'snmp_community' => 'snmp-community',
                       'z' => 'z',
                       'debug' => 'debug',
                       'gen_completion' => 'gen-completion',
                       'help' => 'help',
                       'interactive' => 'interactive',
                       'quiet' => 'quiet',
                       'short_help' => 'short-help',
                       'tiny_help' => 'tiny-help',
                       'verbose' => 'verbose',
  );


  LearnArgsFromConfFile();

  my $result = GetOptions (
                           'snmp-community=s' => \$args{snmp_community},
                           'z' => \$args{z},
                           'debug' => \$args{debug},
                           'gen-completion' => \$args{gen_completion},
                           'help' => \$args{help},
                           'interactive' => \$args{interactive},
                           'quiet' => \$args{quiet},
                           'short-help' => \$args{short_help},
                           'tiny-help' => \$args{tiny_help},
                           'verbose' => \$args{verbose},
  );

  if (!$result) { exit(1); }


  # Positional argument processing

  my $posIdx = 0;
  while (@ARGV) {
    if ($posIdx >= 2) {
      last;
    }
  
    $args{$posToName[$posIdx]} = shift @ARGV;
    if ($posToType[$posIdx] eq 'integer') {
      $args{$posToName[$posIdx]} = 
         StrToNum($args{$posToName[$posIdx]}, "Failed to convert $args{$posToName[$posIdx]} to number");
    }
    delete $requiredArgs{$posToName[$posIdx]};
    $posIdx++;
  }
  @remainingArgs = @ARGV;
  @parsedArgs = @allArgs[0..(scalar(@allArgs)-scalar(@remainingArgs)-1)];

  if($#ARGV > -1) { 
    print "${BOLDr}Unrecognized argument(s):$NORMAL ";
    foreach (@ARGV) { print "$_ "; } print "\n";
    exit 1;
  }

  # Copy over all the arguments that were parsed
  foreach my $arg (keys(%args)) {
    if (defined $args{$arg}) {
      $parsedArgs{$arg} = 1;
    }
  }

  # Put back the default arguments
  foreach my $arg (keys(%defaultArgs)) {
    if (!defined($args{$arg})) {
      $args{$arg} = $defaultArgs{$arg};
    }
  }


  # Standard option processing

  if ($args{gen_completion}) {
    print "--snmp-community --z --debug --help --interactive --quiet --short-help --tiny-help --verbose ";
    exit;
  }

  if ($args{help}) {
    pod2usage(-verbose => 2);    
    exit;
  }
  if ($args{short_help}) {
    pod2usage(-verbose => 1);
    exit;
  }
  if ($args{tiny_help}) {
    my $info = GetArgInfo();
    print "$info->{Name} - $info->{ShortDescription}\n";
    exit;
  }
  my $showCmdLine = 0;
  if ($args{interactive}) {
    PromptForArgs(1, %args);
    $showCmdLine = 1;
  }
  
  # Check for missing required params
  foreach my $key (keys(%requiredArgs)) {
    if (defined $args{$key}) {
      delete $requiredArgs{$key};
    }
  }
  if (scalar(keys(%requiredArgs)) > 0) {
    print "\nMissing some required parameters\n";
    PromptForArgs(1, %requiredArgs);
    $showCmdLine = 1;
  }
  
  # Check that enums have valid values
  my $argInfo = GetArgInfo();
  foreach my $arg (keys(%enumArgs)) {
    if (defined $args{$arg}) {
      if (not defined $enumArgs{$arg}{$args{$arg}}) {
        print "\nInvalid value for argument $arg.  Valid values are:\n";
        foreach my $value (keys(%{$enumArgs{$arg}})) {
          print "  $value\n";
        }
        exit;
      }
    }
  }
  
  if ($showCmdLine) {
    # Output the command line for this
    DisplayCommandLine();
  }

} # ParseArgs


##############################################################################
## PromptForArgs - Will ask the user for values for various arguments
##
## skipAutoArgs: When true, it will not prompt for --interactive, --debug,
##               --quiet, --verbose or --help
##
##############################################################################
sub PromptForArgs {
  my ($skipAutoArgs, %argsForPrompting) = @_;
  my $argInfo = GetArgInfo();
  
  print "\nInteractive Input:\n\n";
  foreach my $arg (@{$argInfo->{Args}}) {
    my $name = $arg->{Name};
    my $perlName = $arg->{PerlName};
    if (not exists $argsForPrompting{$perlName}) {
      next;
    }
    if ($skipAutoArgs && 
        ($name =~ /^(debug)|(interactive)|(quiet)|(verbose)|(help)|(gen-completion)$/)) {
      next;
    }
    my $desc = $arg->{Description};
    my $space = " " x (length($name) + 3);
    $desc =~ s/(.{1,75 - length($name)})(?:\s|$|\n)/$1\n$space/g;
    my $prompt = "\n$BOLD$name$NORMAL - $arg->{Description}";
    my $default = '';
    my $defVal = '';
    if (defined $args{$perlName}) {
      $default = " [$args{$perlName}]";
      $defVal = $args{$perlName};
    }
    elsif ($arg->{Default}) {
      $default = " [$arg->{Default}]";
      $defVal = $arg->{Default};
    }
    while (1) {
      if ($arg->{ValType} eq 'boolean') {
        print $prompt . "\nEnter value for flag (undef, 0 or 1)$default: ";
      }
      elsif ($arg->{ValType} =~ /integer|float/) {
        print $prompt . "\nEnter numeric value$default: ";
      }
      elsif ($arg->{ValType} eq 'enum') {
        print $prompt . "\nSelect value: ";
      }
      else {
        print $prompt . "\nEnter value$default: ";
      }
      my $response;
      if ($arg->{ValType} eq 'enum') {
        print "\n";
        $default = '';
        my $num = 1;
        my $defaultNum;
        foreach my $val (@{$arg->{EnumList}}) {
          print "  $num: $val\n";
          if ($val eq $defVal) {
            $default = "[$num]";
            $defaultNum = $num;
          }
          $num++;
        }
        while (1) {
          print "Select number$default: "; 
          chomp($response = <STDIN>);
          if ($response eq '') {
            $response = defined $defaultNum ? $defaultNum : 0;
          }
          if ($response >= 1 &&
              $response <= scalar(@{$arg->{EnumList}})) {
            $response = $arg->{EnumList}[$response-1];
            last;
          }
          print "Invalid selection - try again\n";
        }
      }
      else {
        chomp($response = <STDIN>);
      }
      if ($arg->{Required} && 
          (not defined $args{$perlName}) &&
          $response eq '') {
        print "You must enter a value for this argument\n";
      }
      else {
        if ($response eq '' && 
            defined $args{$perlName}) {
          # Keep the same value
        }
        elsif ($response eq '' && 
               defined $arg->{Default}) {
          $args{$perlName} = $arg->{Default};
        }
        else {
          if ($arg->{ValType} eq 'integer') {
            $args{$perlName} =
              StrToNum($response, "Failed to convert $response to number");
          }
          else {
            $args{$perlName} = $response;
          }
        }
        if (($arg->{ValType} eq 'boolean') && 
            (($args{$perlName} eq 'undef') || ($args{$perlName}) eq ''))  {
          $args{$perlName} = undef;
        }
        last;
      }
    }
  }

}



##############################################################################
## LearnArgsFromConfFile - This will open the appropriate .conf file to get
##                       additional arguments
##
##############################################################################
sub LearnArgsFromConfFile {
  my $homeDir;
  if (exists $ENV{'HOME'}) {
    $homeDir = $ENV{'HOME'};
  } else {
    # Some flavour of Windows? Try this:
    $homeDir = $ENV{'USERPROFILE'};
  }
  return if !(-e "$homeDir");
  return if !(-e "$homeDir/.scripts");

  my $conf = "$homeDir/.scripts/rs-trace-client.conf";
  return if !(-e $conf);

  # The file exists - suck it in and parse out the goodness
  open(IN, $conf) || return;
  my @data = <IN>;
  close(IN);

  my $section = "";
  my $quiet = 0;
  foreach my $line (@data) {
    if ($line =~ /^\s*\[([^\]]+)\]/) {
      $section = $1;
    }
    elsif ($section =~ /^(args)|(command-line-args)|(cmd-line-args)|(cmdline-args)/i || $section eq "") {
      if ($line =~ /^\s*([\w\-\_\d]+)\s*=\s*([^\n\s\#\;]+)/) {
        my $arg = $1;
        my $val = $2;
        print "Defaulting argument --$1 to $2 from .conf file\n" unless $quiet;
        # Put the arg at the head of the arg list
        unshift(@ARGV, "--$arg=$val");
      }
      elsif ($line =~ /^\s*([\w\-\_\d]+)\s*$/) {
        my $arg = $1;
        print "Defaulting flag --$1 to on from .conf file\n" unless $quiet;
        # Put the arg at the head of the arg list
        unshift(@ARGV, "--$arg");
      }
    }
    elsif ($section =~ /^global-?settings/i) {
      if ($line =~ /^\s*([\w\-\_\d]+)\s*=\s*([^\n\s\#\;]+)/) {
        my $arg = $1;
        my $val = $2;
        if (lc($arg) eq "quiet") {
          $quiet = $val;
          unshift(@ARGV, "--quiet") if $val;
        }
      }
    }
  }
  
} # LearnArgsFromConfFile


##############################################################################
## GetArgInfo - This will return all the script information in perl
##              struct form.
##
##############################################################################
sub GetArgInfo {

  my $cfgInfo = {
             'SuperScriptRevision' => '3017',
             'ShortDescription' => 'Do an L2 and L3 traceroute through the network for the specified client.',
             'ParsingType' => 'unordered',
             'Description' => 'This script will log into the specified router and attempt to trace the route of the specified client through the L2 and L3 network.  It will use SNMP along with LLDP and CDP information to figure out the path.
',
             'Name' => 'rs-trace-client',
             'Args' => [
                         {
                           'Type' => 'positional',
                           'Default' => '',
                           'Required' => 1,
                           'ValType' => 'string',
                           'Name' => 'router',
                           'Description' => 'The router where the client exists',
                           'PerlName' => 'router'
                         },
                         {
                           'Type' => 'positional',
                           'Default' => '',
                           'Required' => 1,
                           'ValType' => 'string',
                           'Name' => 'client-name',
                           'Description' => 'The client to trace',
                           'PerlName' => 'client_name'
                         },
                         {
                           'Type' => 'named',
                           'Default' => 'public',
                           'Required' => 0,
                           'ValType' => 'string',
                           'Name' => 'snmp-community',
                           'Description' => 'Community name to use in SNMP requests',
                           'PerlName' => 'snmp_community'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Default' => 0,
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Make a tar-gzipped file of rs-trace-client and all required modules',
                           'Name' => 'z',
                           'PerlName' => 'z'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Turn on all debug output.',
                           'Name' => 'debug',
                           'PerlName' => 'debug'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Prints out completion info for the parameters',
                           'Name' => 'gen-completion',
                           'PerlName' => 'gen_completion'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out usage info for this script',
                           'Name' => 'help',
                           'PerlName' => 'help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Query the user for values for each of the arguments, providing help for each.  This will print out the appropriate command line for future reference before executing the script.',
                           'Name' => 'interactive',
                           'PerlName' => 'interactive'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Reduce the amount of output to the bare minimum.',
                           'Name' => 'quiet',
                           'PerlName' => 'quiet'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out usage summary for this script',
                           'Name' => 'short-help',
                           'PerlName' => 'short_help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out one line description for this script',
                           'Name' => 'tiny-help',
                           'PerlName' => 'tiny_help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out more user-level output',
                           'Name' => 'verbose',
                           'PerlName' => 'verbose'
                         }
                       ],
             'PositionalListIdx' => undef
           };

  return $cfgInfo;

} # GetArgInfo


##############################################################################
## DisplayCommandLine - This will print out the command line for the
##                      current arguments
##
##############################################################################
sub DisplayCommandLine {

  my $argInfo = GetArgInfo();

  # my $output = "$argInfo->{Name} ";
  my $output = "$0 ";
  my $positional = '';

  foreach my $arg (@{$argInfo->{Args}}) {
    my $name = $arg->{Name};
    my $perlName = $arg->{PerlName};
    if (not defined $args{$perlName}) {
      next;
    }
    if (defined $arg->{Default} && 
        $args{$perlName} eq $arg->{Default}) {
      next;
    }
    if ($perlName eq 'interactive') {
      next;
    }

    my $value = $args{$perlName};
    if ($value =~ /\s/) {
      $value = "'$value'";
    }
    
    if ($arg->{Type} eq 'named') {
      if ($arg->{ValType} eq 'boolean') {
        if (defined $args{$perlName}) {
          if ($args{$perlName} == 0) {
            $output .= "--no-$name ";
          }
          else {
            $output .= "--$name ";
          }
        }
      }
      else {
        $output .= "--$name=$value ";
      }
    }
    else {
      if (ref $value eq 'ARRAY') {
        if (scalar(@{$value} > 1) || $value->[0] ne '') {
          $positional .= "@{$value} ";
        }
      }
      else {
        $positional .= "$value ";
      }
    }

  }
  
  print "Command line:\n";
  print "$output$positional\n\n";

} # DisplayCommandLine #


##############################################################################
## Log - This will output messages of various levels
##
##############################################################################
sub Log {
  my ($level, $message, $addCaller) = @_;

  my $outputMsg = 0;
  if (!$args{quiet}) {
    if ($level eq "DEBUG") {
      if ($args{debug}) {
        $outputMsg = 1;
      }
    }
    elsif ($level eq "INFO") {
      if ($args{debug} || $args{verbose}) {
        $outputMsg = 1;
      }
    }
    elsif ($level eq "WARN") {
        $outputMsg = 1;
    }
  }

  if (($level eq "ERROR") || ($level eq "FATAL") || ($level eq "MSG")) {
    $outputMsg = 1;
  }
  
  if ($outputMsg) {
    if (($level ne "MSG") || $addCaller) {
      print "$level: ";
    }
    if ($addCaller) {
      my @caller = caller(1);
      $caller[1] =~ s/^.*\///;
      print "$caller[1]:$caller[2]: ";
    }
    print "$message\n";
  }

  if ($level eq "FATAL") {
    exit(1);
  }

} # Log

sub Fatal { Log("FATAL", @_) };
sub Error { Log("ERROR", @_) };
sub Warn  { Log("WARN", @_) };
sub Info  { Log("INFO", @_) };
sub Debug { Log("DEBUG", @_) };
sub Msg   { Log("MSG", @_) };



##############################################################################
## StrToNum - This will convert all types of strings into numbers
##
##############################################################################
sub StrToNum {
  my ($string, $failMsg) = @_;

  if ($string !~ 
      /^([-+]?_*[1-9][0-9_]*  |
         0x_*[0-9a-f][0-9a-f_]* |
         0b_*[01][01_]*         |
         0[0-7_]*)$
      /xi) {
    Fatal($failMsg);
  }

  my $num = eval($string);
  
  if ($@) {
    Fatal($@);
  }

  return $num;

}
  



__END__

=head1 NAME

rs-trace-client

=head1 DESCRIPTION

This script will log into the specified router and attempt to trace the route of the specified client through the L2 and L3 network.  It will use SNMP along with LLDP and CDP information to figure out the path.


=head1 OPTIONS

rs-trace-client [OPTIONS] <router> <client-name> 

Where:

=over

=item router (string) B<*Required*>

The router where the client exists

=item client-name (string) B<*Required*>

The client to trace

=item --snmp-community=<string>

Community name to use in SNMP requests
[Default: public]

=item --z

Make a tar-gzipped file of rs-trace-client and all required modules

=item --interactive

Query the user for values for each of the arguments, providing help for each.  This will print out the appropriate command line for future reference before executing the script.

=item --help, --short-help, --tiny-help

Display various levels of usage information

=item --quiet, --verbose, --debug

Control the amount of information printed during execution

=back

