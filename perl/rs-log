#!/usr/bin/perl
#
# Script: rs-log
#
# This script will log into the specified router and do a tail -F on the
# debug.log.  It will take that output and parse it, storing each column worth
# of data in a separate array so that it is possible for the user to select
# which columns to display.
# 
#
# The framework of the script was autogenerated by version 6990 of
# /opt/soldev/devtools/bin/super-script.
#
#############################################################################


use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;
use Pod::Usage;
use JSON;

use constant BOLD    => "\e[1m";
use constant NORMAL  => "\e[0m";
my $BOLD   = BOLD;
my $NORMAL = NORMAL;
my $BOLDr  = "\e[31m\e[1m";  # Red
my $BOLDg  = "\e[32m\e[1m";  # Green
my $BOLDy  = "\e[35m\e[1m";  # Green


# Main hash - all the argument values will be in here after parsing
my %args = (
            router => undef,
            port => '0',
            host => '0',
            name => 'solace',
            lines => '100000',
            filter => '',
            dbg => '1',
            event => '0',
            colour => '1',
            warn => '0',
            debug => undef,
            gen_completion => undef,
            help => undef,
            interactive => undef,
            quiet => undef,
            short_help => undef,
            tiny_help => undef,
            verbose => undef,
);

# Arrays to hold the parsed and unparsed args
my @remainingArgs;
my @allArgs;
my @parsedArgs;
my %parsedArgs;

ParseArgs();

##--User Code Start--##

# Don't modify anything outside of the User Code Start/End markers or
# it will be lost if the script's configuration is changed

use Term::ReadKey;
use Term::Pager;
use English;
use Expect;
use FindBin;
use lib "$FindBin::Bin/../../../lib/perl";
use lib "$FindBin::Bin/../lib/perl";
use lib "$FindBin::Bin/lib/perl";
use Solace::LogParser;

my %colours = (
  WARN  => $ENV{RS_LOG_WARN_COL}  || 33,
  ERROR => $ENV{RS_LOG_ERROR_COL} || 31,
  EVENT => $ENV{RS_LOG_EVENT_COL} || 36,
  DOCKER => $ENV{RS_LOG_DOCKER_COL} || 35,
    );

# Globals to hold the screen's dimensions
my ($termWidth_g, $termHeight_g) = GetTerminalSize();

# Globals to hold the data
my $lineWrPtr_g = 0;
my @data;

# Constants to do efficient array storage (rather than hash)
my $enum = 0;
use constant FIELD_DATE => $enum++;
use constant FIELD_TIME => $enum++;
use constant FIELD_LEVEL => $enum++;
use constant FIELD_ROUTER => $enum++;
use constant FIELD_USER => $enum++;
use constant FIELD_PID => $enum++;
use constant FIELD_DIR => $enum++;
use constant FIELD_FILE => $enum++;
use constant FIELD_TYPE => $enum++;
use constant FIELD_THREAD => $enum++;
use constant FIELD_MSG => $enum++;
use constant NUM_FIELDS => $enum;

##
# Globals for selecting columns
##

# Column control
my %colControl_g = ((FIELD_DATE) => {Enabled => 0},
                    (FIELD_TIME) => {Enabled => 1},
                    (FIELD_LEVEL) => {Enabled => 0},
                    (FIELD_ROUTER) => {Enabled => 0},
                    (FIELD_USER) => {Enabled => 0},
                    (FIELD_PID) => {Enabled => 0},
                    (FIELD_DIR) => {Enabled => 0},
                    (FIELD_FILE) => {Enabled => 1},
                    (FIELD_TYPE) => {Enabled => 0},
                    (FIELD_THREAD) => {Enabled => 0},
                    (FIELD_MSG) => {Enabled => 1},
);

# Columns displayed by default
my @selCols_g;

# Info about the columns
my %colInfo_g = ((FIELD_TIME) => {Format => "%8s", Width => 8},
                 (FIELD_FILE) => {Format => "%-35s", Width => 35},
                 (FIELD_MSG)  => {Format => "%s", Width => -1});

# Format string for the currently selected columns
my $colFormat_g = "";

# Keep track of where the message column will start
my $msgStartCol_g;


# Handler for window changes
$SIG{WINCH} = 'WindowChangeHandler';

# Modes
#
use constant APPLIANCE_MODE => 0;
use constant VMR_CONTAINER_MODE => 1;
use constant VMR_HOST_MODE => 2;

# Call main - the start of the script
Main();

##############################################################################
## Main - Starting point for the script
##
##############################################################################
sub Main {
  print "\e]0;Debug log for $args{router}\a";
  UpdateColumnInfo();

  Fatal("Must monitor at least one of the debug.log or event.log") if !$args{dbg} && !$args{event};
  
  while (1) {
    if ($args{router} =~ /^sm/i) {
      DisplaySmLog();
    } else {
      my $session = ConnectToRouter();
      DisplayLog($session->{session}, $session->{path}, $session->{docker_log}, $session->{router_type});
    }

  }

}


##############################################################################
## UpdateColumnInfo -
##
## calculates some information about the currently select columns
##
##############################################################################
sub UpdateColumnInfo {

  for my $col (0 .. NUM_FIELDS-1) {
    if($colControl_g{$col}{Enabled}) {
      push(@selCols_g, $col);
    }
  }

  foreach my $col (@selCols_g) {
    $colFormat_g .= "$colInfo_g{$col}{Format}  ";
    if ($col ne "Msg") {
      $msgStartCol_g += $colInfo_g{$col}{Width} + 2;
    }
  }
  $msgStartCol_g += 9;
  $colFormat_g .= "\n";

} # UpdateColumnInfo #

use lib "$FindBin::Bin/../lib/perl";
use lib "$FindBin::Bin/../../lib/perl";
use lib '/home/jmoser/work/devtools/jmoser/lib/perl';
use File::Tail::Multi;
##############################################################################
## DisplaySmLog
##
##############################################################################
sub DisplaySmLog {

  my $files = [ '/usr/sw/jail/logs/debug.log' ];
  push(@{$files}, '/usr/sw/jail/logs/event.log') if $args{event};

  #TODO use the router index to filter the log files
  #
  my $rtr = 0;
  $rtr = $1 if ($args{router} =~ /:(\d+)/);

  my $ref = File::Tail::Multi->new( Files => $files,
                                    Function => \&__readSm,
                                    RemoveDuplicate => 1,
                                    NumLines => $termHeight_g,
                                    MaxAge => 10000000,
                                  );

  {
    my $patterns = [];

    chomp(my $user = `whoami`);
    push(@{$patterns}, $user) if (!$? && $user =~ /\w/);

    push(@{$patterns}, ' event: ') if $args{event};

    $ref->Pattern($patterns) if (scalar @{$patterns});
  }

  while(1) {
     $ref->read();
  }

  sub __readSm {
    my $lines = shift;
    foreach my $line (@{$lines}) {

      next if ($args{filter} ne '' && $line !~ /$args{filter}/);

      my ($date, $time, $lvl,  $rtr,  $user, $pid,  $dir,  $file, $type, $thd,  $msg ) =
         (undef, undef, '',    '',    '',    'n/a', '',    '',    'n/a', 'n/a', undef);

      # Events
      #
      if (!$msg || $msg =~ /^\s*$/) {
      ($date, $time, $rtr, $msg) =
      ($line =~ /(\w{3}\s+\d+)                        # date
                 \s+
                 (\d+:\d+:\d+)                        # time
                 \s+
                 (\w+)                                # rtr
                 \s+event:\s+
                 (.+)                                 # msg
                /x);
          $msg = 'EVENT    ' . $msg if $msg && $msg !~ /^\s*$/;
      }

      # Majority of all logs
      #
      if (!$msg || $msg =~ /^\s*$/) {
      ($date, $time, $rtr, $user, $pid, $dir, $file, $type, $thd, $msg) =
      ($line =~ /(\w{3}\s+\d+)                        # date
                 \s+
                 (\d+:\d+:\d+)                        # time
                 \s+
                 (\w+)                                # rtr
                 \s+
                 ([\w\d\-_]+)                         # user
                 \[(\d+)\]:?                          # pid
                 \s+
                 ([\w\d\/_\-\.]+)?                    # dir
                 \s+
                 ([\w\d\/_\-\.]+:\d+)                 # file
                 \s+
                 \(([\w\_\-\d]+)\s*-\s*[\dxa-fA-F]+\) # type
                 \s+
                 ([^\s]+)                             # thd
                 \s+
                 (.+)                                 # msg
                /x);
      }

      # AFW logs
      #
      if (!$msg || $msg =~ /^\s*$/) {
      ($date, $time, $rtr, $user, $msg) =
      ($line =~ /(\w{3}\s+\d+)                        # date
                 \s+
                 (\d+:\d+:\d+)                        # time
                 \s+
                 (\w+)                                # rtr
                 \s+
                 (\w+):                               # user
                 \s+
                 (.+)                                 # msg
                /x);
      }


      # solcache logs
      #
      if (!$msg || $msg =~ /^\s*$/) {
      my $tmp = '';
      ($date, $time, $rtr, $thd, $pid, $user, $tmp, $file, $msg) =
      ($line =~ /(\w{3}\s+\d+)                        # date
                 \s+
                 (\d+:\d+:\d+)                        # time
                 \s+
                 (\w+)                                # rtr
                 \s+
                 ([\w\d\-_]+)                         # thd
                 \[(\d+)\]:?                          # pid
                 \s+
                 ([\w\d\-_]+)                         # user
                 \s+
                 ([A-Z]+)                             # tmp
                 \s+
                 \(([\w\d\/_\-\.]+:\d+).*?\)          # file
                 \s+
                 (.+)                                 # msg
                /x);
      $msg = ($tmp || '') . ' ' . ($msg || '');
      }

      # other solcache logs
      #
      if (!$msg || $msg =~ /^\s*$/) {
      my $tmp = '';
      ($date, $time, $rtr, $thd, $pid, $user, $tmp, $msg) =
      ($line =~ /(\w{3}\s+\d+)                        # date
                 \s+
                 (\d+:\d+:\d+)                        # time
                 \s+
                 (\w+)                                # rtr
                 \s+
                 ([\w\d\-_]+)                         # thd
                 \[(\d+)\]:?                          # pid
                 \s+
                 ([\w\d\-_]+)                         # user
                 \s+
                 ([A-Z]+)                             # tmp
                 \s+
                 (.+)                                 # msg
                /x);
      $msg = ($tmp || '') . ' ' . ($msg || '');
      }

      # script logs
      #
      if (!$msg || $msg =~ /^\s*$/) {
      ($date, $time, $rtr, $thd, $pid, $file, $msg) =
      ($line =~ /(\w{3}\s+\d+)                        # date
                 \s+
                 (\d+:\d+:\d+)                        # time
                 \s+
                 (\w+)                                # rtr
                 \s+
                 ([\w\d\-_\.]+)                         # thd
                 \[(\d+)\]:?                          # pid
                 \s+
                 ([\w\d\/_\-\.]+:\d+)                 # file
                 \s+
                 (.+)                                 # msg
                /x);
      ($dir, $file) = ($file =~ /(.+\/)([\w\d\/_\-\.]+:\d+)/) if $file && $file =~ /\w/;
      }

      if (!$msg || $msg =~ /^\s*$/) {
        print "$line";
      } else {
        StoreFields($date, $time, $lvl, $rtr, $user, $pid, $dir, $file, $type, $thd, $msg);
        UpdateScreen();
      }

    }
  }

} # DisplaySmLog #

##############################################################################
## DisplayLog - Read the log entries from the router and display them
##
##############################################################################
sub DisplayLog {
  my ($exp, $path, $docker_log, $router_type) = @_;

  my $line = 0;
  my $cmd = "";
  if ($router_type eq 'VMR')  {
    $cmd .= "sudo "
  }
  $cmd .= "tail -F --lines=$termHeight_g ";
  $cmd .= " $path/debug.log" if $args{dbg};
  $cmd .= " $path/event.log" if $args{event};
  $cmd .= " $docker_log";
  $exp->send("$cmd\r");
  my ($match, $error) = $exp->expect(5, "\n");
  ReadMode 4;

  while (1) {
    my ($match, $error) = $exp->expect(1, "\n");
    if (defined $error && $error ne "1:TIMEOUT") {
      print "Error: $error\n";
      return;
    }
    my $output = $exp->before();
    if (defined $match || (defined $output && $output ne "")) {

      if ($output =~ /^==>/) {
        next;
      }
      if ($output =~ /^\s*\r?$/) {
        next;
      }

      if ($args{filter} ne '' && $output !~ /$args{filter}/) {
        next;
      }

      my $json = 0;
      eval {
        my $test = decode_json($output);
        print "$test->{time}\r";
        my ($date, $time) = split /T/, $test->{time};
        my $msg = "DOCKER   $test->{log}";
        $msg =~ s/\s+$//s;
        StoreFields($date,substr($time, 0, 12),"","","", "", "", "", "", "",  $msg);
        UpdateScreen();
        $json = 1;
      }or do {
        my ($date, $time, $level, $router, $user, $pid, $dir, $file, $type, $thread, $msg) =
            Solace::LogParser::parseLine($output, 1);
        if ($output =~ s/ event: //s) {
            $msg =~ s/^\s*//s;
            $msg =~ s/\s*$//s;
            $msg = "EVENT    $msg";
        }

        if (!$date) {
          # print "Failed to parse: >>$output<<\n";
          print "$output\n";
          next;
        }

        # print "$date, $time, $level, $router, $user, $pid, $dir, $file, $type, $thread, $msg\n";

        StoreFields($date, $time, $level, $router, $user, $pid, $dir, $file, $type, $thread, $msg);
        UpdateScreen();

      };

    }

    while (1) {
      ReadMode 4;
      my $char = ReadKey(-1);
      # ReadMode 0;
      if (defined $char) {
        # print "received: " . ord($char) ."\n";
        if ($char eq "m") {
          # Back from more - dump out the last N lines
          # TODO
        } elsif (ord($char) == 27) {
          ReadMode 4;
          $char = ReadKey(-1);
          # ReadMode 0;

          if (ord($char) == 91) {
            ReadMode 4;
            $char = ReadKey(-1);
            # ReadMode 0;

            if (ord($char) == 65) {
              Debug("up");
            } elsif (ord($char) == 66) {
              Debug("down");
            }
          }

          # Back from more - dump out the last N lines
          # TODO
        } elsif (($char eq "") || ($char eq "q")) {
          print "Exiting\n";
          ReadMode 0;
          exit(0);
        } elsif (ord($char) == 10) {
          print "\n";
        } else {
          Debug("received: " . ord($char));
        }
      }
      else {
        last;
      }
    }
  }


} # DisplayLog #


##############################################################################
## UpdateScreen -
##
## This will redraw the screen with the appropriate columns, showing the
## requested range.
##
##############################################################################
sub UpdateScreen {
  my ($lastLine) = @_;

  # print "$output\n";
  my @params;
  foreach my $col (@selCols_g) {
    push(@params, $data[$col][$lineWrPtr_g-1]);
  }

  if ($args{colour}) {
      $params[-1] = "\e[$colours{WARN}m$params[-1]\e[0m" if $params[-1] =~ /^WARN/ && $args{warn};
      $params[-1] = "\e[$colours{ERROR}m$params[-1]\e[0m" if $params[-1] =~ /^ERROR/;
      $params[-1] = "\e[0m\e[$colours{EVENT}m$params[-1]\e[0m" if $params[-1] =~ /^EVENT/;
      $params[-1] = "\e[0m\e[$colours{DOCKER}m$params[-1]\e[0m" if $params[-1] =~ /^DOCKER/;
  }
  my $text = sprintf($colFormat_g, @params);

  if (length($text) > $termWidth_g) {
    # Word wrap the text
    my $indent = " " x $msgStartCol_g;
    $text =~ s/^(.{1,$termWidth_g})\s+/$1\n$indent/g;
    print $text;
  }
  else {
    print "$text";
  }

} # UpdateScreen #


##############################################################################
## StoreFields -
##
## Put all the parsed fields into a datastructure so that we can access them
## later
##
##############################################################################
sub StoreFields {

  my $idx = 0;
  foreach my $field (@_) {
    $data[$idx][$lineWrPtr_g] = $field;
    $idx++;
  }

  $lineWrPtr_g++;
  if ($lineWrPtr_g >= $args{lines}) {
    $lineWrPtr_g = 0;
  }

} # StoreFields #



##############################################################################
## ConnectToRouter - This will log into the router
##
##############################################################################
sub ConnectToRouter {
  my $mode = shift();

  sub __connect { 
    my ($port) = @_;
    ReadMode 0;
    print "Trying to connect to $args{router} port $port...";
    my $session;
    my $auto_port = 0;
    my $auto_user = 0;
    my $user;
    if ($port eq "auto") {
        $auto_port = 1;
        $port = 22; 
    }
    while(1) {
      $session = new Expect();
      $session->raw_pty(1);
      $session->log_stdout(0);
      if ($auto_port) {
          if ($port == 22) {
              $port = 2222;
              if ($auto_user++ % 2) { 
                $user = "support";  
              } else { 
                $user = "sysadmin"; 
              }
          } else {
              $port = 22;
          }
      } 
      $session->spawn("ssh", "-p $port", "$user\@$args{router}",
                      "-oServerAliveInterval=5",
                      "-oStrictHostKeyChecking=no",
                      "-oUserKnownHostsFile=/dev/null");

      expectPass:
      my $match = $session->expect(5,
                                   ['-re', 'assword: '],
                                   ['-re', '\]\$ '],
                                   ['-re', 'yes']);

      next if !defined $match || !$match;
      last if $match == 2;
      if ($match == 1) {
        $session->send("$user\r");
        $match = $session->expect(5,
                                  ['-re', '\]\$ ']);
        last if $match;
      } elsif ($match == 3) {
        $session->send("yes\r");
        goto expectPass;
      }
      print '.';
      sleep(1);
    }
    $session->clear_accum();
    print "\n";

    if($user eq "support") { 
      return {
        session => $session,
        path => '/usr/sw/jail/logs',
        docker_log => '',
        router_type => 'appliance' 
      };
    } elsif ($user eq "sysadmin") { 
      my $attempts = 40;
      while (1) {

        $session->send("docker inspect --format='{{.LogPath}} {{ range .Mounts }}{{ if eq .Destination \"/usr/sw/jail\" }}{{ .Source }}{{ end }}{{ end }}' $args{name}\r");
        my ($match, $error) = $session->expect(5, "\n");
        if (defined $error && $error ne "1:TIMEOUT") {
          if (--$attempts > 0) {
            select(undef, undef, undef, 0.5);
            next;
          }
          Fatal("Error: could not determine jail volume mount for container '$args{name}' ($error)");
        }
        my $output = $session->before();
        if ($output !~ /\w/) { 
          if (--$attempts > 0) { 
            select(undef, undef, undef, 0.5);
            next;
          }
          Fatal("Unable to locate jail volume mount for container '$args{name}'") if $output !~ /\w/;
        }
        my @outputSplit = split / /, $output;
        my $docker_log = $outputSplit[0];
        $session->send("docker volume inspect jail --format '{{ .Options.device }}'\r");
        my $pathExpect = $session->expect(10,
                                  "no value>",
                                  "mnt/vmr/jail"
                                  );

        my $path;
        if ($pathExpect == 2) { $path = "/mnt/vmr/jail"; }
        if ($pathExpect == 1) { $path = $outputSplit[1]; }

        if (index($output, "Error:") != -1 or index($output, "sysadmin@") != -1){
          if (--$attempts > 0) {
            $session  = __connect($args{port} ? $args{port} : "auto");
            select(undef, undef, undef, 0.5);
            next;
          }
          return __connect();
        }
        return { session => $session, 
                path  => "$docker_log $path" . '/logs', 
                docker_log => $docker_log,
                router_type => 'VMR' };
      }
    }
    return $session;
  }

  return __connect($args{port} ? $args{port} : "auto");
    

} # ConnectToRouter #



##############################################################################
## WindowChangeHandler - Called when we receive a window change signal
##
##############################################################################
sub WindowChangeHandler {

  ($termWidth_g, $termHeight_g) = GetTerminalSize();
  # print "Window is now ${termWidth_g}x$termHeight_g\n";

} # WindowChangeHandler #




##--User Code End--##


##############################################################################
## ParseArgs - Parse the command line arguments
##
##############################################################################
sub ParseArgs {
  
  # Options Parsing
  @allArgs = @ARGV;

  my %defaultArgs = %args;
  %args = ();

  # Converts position arguments to names
  my @posToName = (
              'router',
              'filter',
  );

  # Converts position arguments to names
  my @posToType = (
              'string',
              'string',
  );

  # All required arguments
  my %requiredArgs = (
           'router' => 1,
  );

  # All hides-required arguments
  my %hidesRequiredArgs = (
  );

  # All enum arguments
  my %enumArgs = (
  );

  # Cross ref of perl version of args to command line version
  my %perlToCmdArg = (
                       'router' => 'router',
                       'port' => 'port',
                       'host' => 'host',
                       'name' => 'name',
                       'lines' => 'lines',
                       'filter' => 'filter',
                       'dbg' => 'dbg',
                       'event' => 'event',
                       'colour' => 'colour',
                       'warn' => 'warn',
                       'debug' => 'debug',
                       'gen_completion' => 'gen-completion',
                       'help' => 'help',
                       'interactive' => 'interactive',
                       'quiet' => 'quiet',
                       'short_help' => 'short-help',
                       'tiny_help' => 'tiny-help',
                       'verbose' => 'verbose',
  );


  LearnArgsFromConfFile();

  my $result = GetOptions (
                           'port=o' => \$args{port},
                           'host' => \$args{host},
                           'name=s' => \$args{name},
                           'lines=o' => \$args{lines},
                           'dbg!' => \$args{dbg},
                           'event' => \$args{event},
                           'colour!' => \$args{colour},
                           'warn' => \$args{warn},
                           'debug' => \$args{debug},
                           'gen-completion' => \$args{gen_completion},
                           'help' => \$args{help},
                           'interactive' => \$args{interactive},
                           'quiet' => \$args{quiet},
                           'short-help' => \$args{short_help},
                           'tiny-help' => \$args{tiny_help},
                           'verbose' => \$args{verbose},
  );

  if (!$result) { exit 1; }

  # Positional argument processing

  my $posIdx = 0;
  while (@ARGV) {
    last if $posIdx >= 2;
  
    $args{$posToName[$posIdx]} = shift @ARGV;
    if ($posToType[$posIdx] eq 'integer') {
      $args{$posToName[$posIdx]} = 
         StrToNum($args{$posToName[$posIdx]}, "Invalid argument, failed to convert $args{$posToName[$posIdx]} to number");
    }
    delete $requiredArgs{$posToName[$posIdx]};
    $posIdx++;
  }

  @remainingArgs = @ARGV;
  @parsedArgs = @allArgs[0..(scalar(@allArgs)-scalar(@remainingArgs)-1)];

  Fatal("${BOLDr}Unrecognized argument(s):$NORMAL " . join(' ', @ARGV)) if $#ARGV > -1;

  foreach my $arg (keys(%args)) {
    $parsedArgs{$arg} = 1 if defined $args{$arg};
  }

  foreach my $arg (keys(%defaultArgs)) {
    $args{$arg} = $defaultArgs{$arg} if !defined $args{$arg};
  }

  # Standard option processing

  if ($args{gen_completion}) {
    print "--port --host --name --lines --dbg --event --colour --warn --debug --help --interactive --quiet --short-help --tiny-help --verbose ";
    exit 1;
  }

  if ($args{help}) {
    
    pod2usage(-verbose => 2);    
    exit 1;
  }
  if ($args{short_help}) {
    
    pod2usage(-verbose => 1);
    exit 1;
  }
  if ($args{tiny_help}) {
    my $info = GetArgInfo();
    print "$info->{Name} - $info->{ShortDescription}\n";
    exit 1;
  }

  my $showCmdLine = 0;
  if ($args{interactive}) {
    PromptForArgs(1, %args);
    $showCmdLine = 1;
  }

  my $hidesRequired = 0;
  foreach my $key (keys(%hidesRequiredArgs)) {
    if (defined $args{$key}) {
      $hidesRequired = 1;
      last;
    }
  }
  
  # Check for missing required params
  if (!$hidesRequired) {
    foreach my $key (keys(%requiredArgs)) {
      if (defined $args{$key}) {
        delete $requiredArgs{$key};
      }
    }
    if (scalar(keys(%requiredArgs)) > 0) {
      print "\nMissing some required parameters\n";
      PromptForArgs(1, %requiredArgs);
      $showCmdLine = 1;
    }
  }
  
  # Check that enums have valid values
  my $argInfo = GetArgInfo();
  foreach my $arg (keys(%enumArgs)) {
    if (defined $args{$arg}) {
      my $argList = ref($args{$arg}) ? $args{$arg} : [$args{$arg}];
      foreach my $val (@{$argList}) {
        if (not defined $enumArgs{$arg}{$val}) {
          print "\nInvalid value '$val' for argument $arg.  Valid values are:\n";
          foreach my $value (keys(%{$enumArgs{$arg}})) {
            print "  $value\n";
          }
          exit 1;
        }
      }
    }
  }
  
  if ($showCmdLine) {
    # Output the command line for this
    DisplayCommandLine();
  }

} # ParseArgs #

##############################################################################
## PromptForArgs - Will ask the user for values for various arguments
##
## skipAutoArgs: When true, it will not prompt for --interactive, --debug,
##               --quiet, --verbose or --help
##
##############################################################################
sub PromptForArgs {
  my ($skipAutoArgs, %argsForPrompting) = @_;
  my $argInfo = GetArgInfo();
  
  print "\nInteractive Input:\n\n";
  foreach my $arg (@{$argInfo->{Args}}) {
    my $name = $arg->{Name};
    my $perlName = $arg->{PerlName};
    if (not exists $argsForPrompting{$perlName}) {
      next;
    }
    if ($skipAutoArgs && 
        ($name =~ /^(debug|interactive|quiet|verbose|help|gen-completion)$/)) {
      next;
    }
    my $desc = $arg->{Description};
    my $space = " " x (length($name) + 3);
    $desc =~ s/(.{1,75 - length($name)})(?:\s|$|\n)/$1\n$space/g;
    my $prompt = "\n$BOLD$name$NORMAL - $arg->{Description}";
    my $default = '';
    my $defVal = '';
    if (defined $args{$perlName}) {
      $default = " [$args{$perlName}]";
      $defVal = $args{$perlName};
    }
    elsif ($arg->{Default}) {
      $default = " [$arg->{Default}]";
      $defVal = $arg->{Default};
    }
    while (1) {
      if ($arg->{ValType} eq 'boolean') {
        print $prompt . "\nEnter value for flag (undef, 0 or 1)$default: ";
      }
      elsif ($arg->{ValType} =~ /integer|float/) {
        print $prompt . "\nEnter numeric value$default: ";
      }
      elsif ($arg->{ValType} eq 'enum') {
        print $prompt . "\nSelect value: ";
      }
      else {
        print $prompt . "\nEnter value$default: ";
      }
      my $response;
      if ($arg->{ValType} eq 'enum') {
        print "\n";
        $default = '';
        my $num = 1;
        my $defaultNum;
        foreach my $val (@{$arg->{EnumList}}) {
          print "  $num: $val\n";
          if ($val eq $defVal) {
            $default = "[$num]";
            $defaultNum = $num;
          }
          $num++;
        }
        while (1) {
          print "Select number$default: "; 
          chomp($response = <STDIN>);
          if ($response eq '') {
            $response = defined $defaultNum ? $defaultNum : 0;
          }
          if ($response >= 1 &&
              $response <= scalar(@{$arg->{EnumList}})) {
            $response = $arg->{EnumList}[$response-1];
            last;
          }
          print "Invalid selection - try again\n";
        }
      }
      else {
        chomp($response = <STDIN>);
      }
      if ($arg->{Required} && 
          (not defined $args{$perlName}) &&
          $response eq '') {
        print "You must enter a value for this argument\n";
      }
      else {
        if ($response eq '' && 
            defined $args{$perlName}) {
          # Keep the same value
        }
        elsif ($response eq '' && 
               defined $arg->{Default}) {
          $args{$perlName} = $arg->{Default};
        }
        else {
          if ($arg->{ValType} eq 'integer') {
            $args{$perlName} =
              StrToNum($response, "Failed to convert $response to number");
          }
          else {
            $args{$perlName} = $response;
          }
        }
        if (($arg->{ValType} eq 'boolean') && 
            (($args{$perlName} eq 'undef') || ($args{$perlName}) eq ''))  {
          $args{$perlName} = undef;
        }
        last;
      }
    }
  }

}



##############################################################################
## LearnArgsFromConfFile - This will open the appropriate .conf file to get
##                       additional arguments
##
##############################################################################
sub LearnArgsFromConfFile {
  my $homeDir;
  if (exists $ENV{'HOME'}) {
    $homeDir = $ENV{'HOME'};
  } else {
    # Some flavour of Windows? Try this:
    $homeDir = $ENV{'USERPROFILE'};
  }
  return if !$homeDir;
  return if !(-e "$homeDir");
  return if !(-e "$homeDir/.scripts");

  my $conf = "$homeDir/.scripts/lab-tools/rs-log.conf";
  return if !(-e $conf);

  # The file exists - suck it in and parse out the goodness
  open(IN, $conf) || return;
  my @data = <IN>;
  close(IN);

  my $section = "";
  my $quiet = 0;
  foreach my $line (@data) {
    if ($line =~ /^\s*\[([^\]]+)\]/) {
      $section = $1;
    }
    elsif ($section =~ /^(args)|(command-line-args)|(cmd-line-args)|(cmdline-args)/i || $section eq "") {
      if ($line =~ /^\s*([\w\-\_\d]+)\s*=\s*([^\n\s\#\;]+)/) {
        my $arg = $1;
        my $val = $2;
        print "Defaulting argument --$1 to $2 from .conf file\n" unless $quiet;
        # Put the arg at the head of the arg list
        unshift(@ARGV, "--$arg=$val");
      }
      elsif ($line =~ /^\s*([\w\-\_\d]+)\s*$/) {
        my $arg = $1;
        print "Defaulting flag --$1 to on from .conf file\n" unless $quiet;
        # Put the arg at the head of the arg list
        unshift(@ARGV, "--$arg");
      }
    }
    elsif ($section =~ /^global-?settings/i) {
      if ($line =~ /^\s*([\w\-\_\d]+)\s*=\s*([^\n\s\#\;]+)/) {
        my $arg = $1;
        my $val = $2;
        if (lc($arg) eq "quiet") {
          $quiet = $val;
          unshift(@ARGV, "--quiet") if $val;
        }
      }
    }
  }
  
} # LearnArgsFromConfFile


##############################################################################
## GetArgInfo - This will return all the script information in perl
##              struct form.
##
##############################################################################
sub GetArgInfo {

  my $cfgInfo = {
             'Lang' => 'perl',
             'SuperScriptRevision' => '6990',
             'ShortDescription' => 'Sensible tail -f of debug.log on specified router',
             'ParsingType' => 'unordered',
             'Description' => 'This script will log into the specified router and do a tail -F on the debug.log.  It will take that output and parse it, storing each column worth of data in a separate array so that it is possible for the user to select which columns to display.
',
             'Name' => 'rs-log',
             'Args' => [
                         {
                           'Type' => 'positional',
                           'Required' => 1,
                           'ValType' => 'string',
                           'Name' => 'router',
                           'Description' => 'The router whose log should be viewed',
                           'PerlName' => 'router'
                         },
                         {
                           'Type' => 'named',
                           'Default' => '0',
                           'Required' => 0,
                           'ValType' => 'integer',
                           'Description' => 'SSH port for the router, defaults to 22 for appliances and VMR containers, defaults to 2222 for VMR hosts',
                           'Name' => 'port',
                           'PerlName' => 'port'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Default' => 0,
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Connect to the VMR host instead of the docker container (do not use on appliances)',
                           'Name' => 'host',
                           'PerlName' => 'host'
                         },
                         {
                           'Type' => 'named',
                           'Default' => 'solace',
                           'Required' => 0,
                           'ValType' => 'string',
                           'Description' => 'Name of container to search for in host mode',
                           'Name' => 'name',
                           'PerlName' => 'name'
                         },
                         {
                           'Type' => 'named',
                           'Default' => '100000',
                           'Required' => 0,
                           'ValType' => 'integer',
                           'Description' => 'Specifies the number of lines of history to keep before it is overwritten',
                           'Name' => 'lines',
                           'PerlName' => 'lines'
                         },
                         {
                           'Type' => 'positional',
                           'Default' => '',
                           'Required' => 0,
                           'ValType' => 'string',
                           'Name' => 'filter',
                           'Description' => 'Regexp applied to all logs - only matching ones are displayed',
                           'PerlName' => 'filter'
                         },
                         {
                           'AllowNo' => 1,
                           'Type' => 'named',
                           'Default' => 1,
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Name' => 'dbg',
                           'Description' => 'Munge in debug.log',
                           'PerlName' => 'dbg'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Default' => 0,
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Munge in event.log',
                           'Name' => 'event',
                           'PerlName' => 'event'
                         },
                         {
                           'AllowNo' => 1,
                           'Type' => 'named',
                           'Default' => 1,
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Use colour coding of log entries',
                           'Name' => 'colour',
                           'PerlName' => 'colour'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Default' => 0,
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Name' => 'warn',
                           'Description' => 'Use colour YELLOW for WARN logs',
                           'PerlName' => 'warn'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Turn on all debug output.',
                           'Name' => 'debug',
                           'PerlName' => 'debug'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Prints out completion info for the parameters',
                           'Name' => 'gen-completion',
                           'PerlName' => 'gen_completion'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out usage info for this script',
                           'Name' => 'help',
                           'PerlName' => 'help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Query the user for values for each of the arguments, providing help for each.  This will print out the appropriate command line for future reference before executing the script.',
                           'Name' => 'interactive',
                           'PerlName' => 'interactive'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Reduce the amount of output to the bare minimum.',
                           'Name' => 'quiet',
                           'PerlName' => 'quiet'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out usage summary for this script',
                           'Name' => 'short-help',
                           'PerlName' => 'short_help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out one line description for this script',
                           'Name' => 'tiny-help',
                           'PerlName' => 'tiny_help'
                         },
                         {
                           'AllowNo' => 0,
                           'Type' => 'named',
                           'Required' => 0,
                           'ValType' => 'boolean',
                           'Description' => 'Print out more user-level output',
                           'Name' => 'verbose',
                           'PerlName' => 'verbose'
                         }
                       ],
             'PositionalListIdx' => undef
           };

  return $cfgInfo;

} # GetArgInfo


##############################################################################
## DisplayCommandLine - This will print out the command line for the
##                      current arguments
##
##############################################################################
sub DisplayCommandLine {

  my $argInfo = GetArgInfo();

  # my $output = "$argInfo->{Name} ";
  my $output = "$0 ";
  my $positional = '';

  foreach my $arg (@{$argInfo->{Args}}) {
    my $name = $arg->{Name};
    my $perlName = $arg->{PerlName};
    if (not defined $args{$perlName}) {
      next;
    }
    if (defined $arg->{Default} && 
        $args{$perlName} eq $arg->{Default}) {
      next;
    }
    if ($perlName eq 'interactive') {
      next;
    }

    my $value = $args{$perlName};
    if ($value =~ /\s/) {
      $value = "'$value'";
    }
    
    if ($arg->{Type} eq 'named') {
      if ($arg->{ValType} eq 'boolean') {
        if (defined $args{$perlName}) {
          if ($args{$perlName} == 0) {
            $output .= "--no-$name ";
          }
          else {
            $output .= "--$name ";
          }
        }
      }
      else {
        $output .= "--$name=$value ";
      }
    }
    else {
      if (ref $value eq 'ARRAY') {
        if (scalar(@{$value} > 1) || $value->[0] ne '') {
          $positional .= "@{$value} ";
        }
      }
      else {
        $positional .= "$value ";
      }
    }

  }
  
  print "Command line:\n";
  print "$output$positional\n\n";
  # `history -s $output$positional`;

} # DisplayCommandLine #


##############################################################################
## Log - Handle output messaging
##
##############################################################################
sub Log {
  my ($level, $message, $addCaller, $opts) = @_;

  return 0 if $level eq 'DEBUG' && ($args{quiet} || !$args{debug});
  return 0 if $level eq 'INFO'  && ($args{quiet} || (!$args{debug} && !$args{verbose}));
  return 0 if $level eq 'WARN'  && $args{quiet};

  print("$level: ") if $level ne 'MSG' || $addCaller;
  if ($addCaller) {
    my @caller = caller(1);
    $caller[1] =~  s/^.*\///;
    print("$caller[1]:$caller[2]: ");
  }
  print("$message\n");

  exit 1 if $level eq 'FATAL';

} # Log #

 
sub Fatal { Log('FATAL', @_) };
sub Error { Log('ERROR', @_) };
sub Warn  { Log('WARN',  @_) };
sub Info  { Log('INFO',  @_) };
sub Debug { Log('DEBUG', @_) };
sub Msg   { Log('MSG',   @_) };



##############################################################################
## StrToNum - Convert strings into numbers
##
##############################################################################
sub StrToNum {
  my ($string, $failMsg) = @_;

  Fatal($failMsg) if $string !~ 
      /^([-+]?_*[1-9][0-9_]*  |
         0x_*[0-9a-f][0-9a-f_]* |
         0b_*[01][01_]*         |
         0[0-7_]*)$
      /xi;

  ($string) = ($string =~ /(.*)/);
  my $num = eval($string);
  
  Fatal($@) if $@;
  return $num;

} # StrToNum #


 

__END__

=head1 NAME

rs-log

=head1 DESCRIPTION

This script will log into the specified router and do a tail -F on the debug.log.  It will take that output and parse it, storing each column worth of data in a separate array so that it is possible for the user to select which columns to display.


=head1 OPTIONS

rs-log [OPTIONS] <router> [filter] 

Where:

=over

=item router (string) B<*Required*>

The router whose log should be viewed

=item filter (string)

Regexp applied to all logs - only matching ones are displayed

=item --port=<integer>

SSH port for the router, defaults to 22 for appliances and VMR containers, defaults to 2222 for VMR hosts

=item --host

Connect to the VMR host instead of the docker container (do not use on appliances)

=item --name=<string>

Name of container to search for in host mode
[Default: solace]

=item --lines=<integer>

Specifies the number of lines of history to keep before it is overwritten
[Default: 100000]

=item --dbg or --no-dbg

Munge in debug.log
[Default: 1]

=item --event

Munge in event.log

=item --colour or --no-colour

Use colour coding of log entries
[Default: 1]

=item --warn

Use colour YELLOW for WARN logs

=item --interactive

Query the user for values for each of the arguments, providing help for each.  This will print out the appropriate command line for future reference before executing the script.

=item --help, --short-help, --tiny-help

Display various levels of usage information

=item --quiet, --verbose, --debug

Control the amount of information printed during execution

=back

